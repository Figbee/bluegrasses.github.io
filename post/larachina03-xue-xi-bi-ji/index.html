<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>larachina03学习笔记 - 罗亭的技术博客</title>
<link rel="shortcut icon" href="https://bluegrasses.github.io/favicon.ico">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css">
<link rel="stylesheet" href="https://bluegrasses.github.io/media/css/tailwind.css">
<link rel="stylesheet" href="https://bluegrasses.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="larachina03学习笔记 - 罗亭的技术博客 - Atom Feed" href="https://bluegrasses.github.io/atom.xml">

    

  <meta name="description" content="杂项问题
postman 启动空白修复

解决方法:
环境变量-&amp;gt;添加系统变量(添加POSTMAN_DISABLE_GPU = true)

cerbot 部署https

利用宝塔更方便点

宝塔远程连接数据库
1.数据库权限设为所..." />
  <meta property="og:title" content="larachina03学习笔记 - 罗亭的技术博客">
  <meta property="og:description" content="杂项问题
postman 启动空白修复

解决方法:
环境变量-&amp;gt;添加系统变量(添加POSTMAN_DISABLE_GPU = true)

cerbot 部署https

利用宝塔更方便点

宝塔远程连接数据库
1.数据库权限设为所..." />
  <meta property="og:type" content="articles">
  <meta property="og:url" content="https://bluegrasses.github.io/post/larachina03-xue-xi-bi-ji/" />
  <meta property="og:image" content="https://bluegrasses.github.io/images/avatar.png">
  <meta property="og:image:height" content="630">
  <meta property="og:image:width" content="1200">
  <meta name="twitter:title" content="larachina03学习笔记 - 罗亭的技术博客">
  <meta name="twitter:description" content="杂项问题
postman 启动空白修复

解决方法:
环境变量-&amp;gt;添加系统变量(添加POSTMAN_DISABLE_GPU = true)

cerbot 部署https

利用宝塔更方便点

宝塔远程连接数据库
1.数据库权限设为所...">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="canonical" href="https://bluegrasses.github.io/post/larachina03-xue-xi-bi-ji/">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
 
  
    <link rel="stylesheet" href="https://bluegrasses.github.io/media/css/prism-synthwave84.css">
  

  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
  
</head>

<body>
  <div class="antialiased flex flex-col min-h-screen" id="app">
    <a href="https://bluegrasses.github.io" class="fixed top-0 left-0 mt-4 bg-black text-white dark:text-gray-700 dark:bg-yellow-50 dark:hover:bg-black dark:hover:text-white inline-flex p-2 pl-8 hover:text-gray-700 hover:bg-yellow-50 font-bold z-10 transition-fast animated fadeInLeft">
      罗亭的技术博客
    </a>
    <div class="max-w-4xl w-full mx-auto">
      <div class="shadow-box bg-white dark:bg-gray-600 rounded-lg pt-32 md:pt-64 px-4 md:px-8 pb-8 animated fadeIn mb-8">
        <h1 class="text-5xl font-semibold leading-normal pb-8 mb-8 border-b-8 border-gray-700">
          larachina03学习笔记
        </h1>
        
        <div class="mb-8 flex flex-wrap">
          <div class="text-gray-400 text-sm mr-4">2020-11-02 · 24 min read</div>
          
            <a href="https://bluegrasses.github.io/tag/dQ2EWYbyS/" class="text-gray-700 text-sm border-b-2 border-dotted border-gray-200 hover:border-gray-600 transition-all duration-100 inline-flex mr-2">
              <i class="ri-hashtag"></i>
              laravel
            </a>
          
        </div>
        <div class="markdown mb-8" v-pre>
          <h2 id="杂项问题">杂项问题</h2>
<h3 id="postman-启动空白修复">postman 启动空白修复</h3>
<blockquote>
<p>解决方法:</p>
<p>环境变量-&gt;添加系统变量(添加POSTMAN_DISABLE_GPU = true)</p>
</blockquote>
<h3 id="cerbot-部署https">cerbot 部署https</h3>
<blockquote>
<p>利用宝塔更方便点</p>
</blockquote>
<h3 id="宝塔远程连接数据库">宝塔远程连接数据库</h3>
<p>1.数据库权限设为所有人或指定ip</p>
<p>2.宝塔安全中放行3306端口</p>
<h2 id="restful设计原则">RESTful设计原则</h2>
<h3 id="常用动词">常用动词</h3>
<ul>
<li>
<p>GET：读取（Read）</p>
</li>
<li>
<p>POST：新建（Create）</p>
</li>
<li>
<p>PUT：更新（Update）</p>
</li>
<li>
<p>PATCH：更新（Update），通常是部分更新</p>
</li>
<li>
<p>DELETE：删除（Delete）</p>
</li>
</ul>
<blockquote>
<p>根据 HTTP 规范，动词一律大写</p>
</blockquote>
<h3 id="版本控制">版本控制</h3>
<p><strong>两种情况:</strong></p>
<p>第一种情况</p>
<p><code>https://api.larabbs.com/v1</code></p>
<p><code>https://api.larabbs.com/v2</code></p>
<p>第二种情况</p>
<p><code>https://api.larabbs.com/ Accept: application/prs.larabbs.v1+json</code></p>
<p><code>https://api.larabbs.com/ Accept: application/prs.larabbs.v1+json</code></p>
<h3 id="路由命名">路由命名</h3>
<p>两个关键词: 复数 命名不要有动词</p>
<p><code>POST https://api.larabbs.com/topic</code></p>
<p><code>GET https://api.larabbs.com/topics/1</code></p>
<p><code>POST https://api.larabbs.com/topics/1/comments</code></p>
<p><code>DELETE https://api.larabbs.com/topics/1/comments/10</code></p>
<h3 id="资源过滤">资源过滤</h3>
<pre><code>?state=closed: 不同状态的资源
?page=2&amp;per_page=100：访问第几页数据，每页多少条。
?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序
</code></pre>
<h3 id="状态码">状态码</h3>
<p>HTTP状态码就是一个三位数, 分成五个类别</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx</td>
<td>相关信息</td>
</tr>
<tr>
<td>2xx</td>
<td>操作成功</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误</td>
</tr>
<tr>
<td>5xx</td>
<td>服务器错误</td>
</tr>
</tbody>
</table>
<blockquote>
<p>200 表示操作成功,但是不同的方法可以返回更精确的状态码</p>
</blockquote>
<pre><code class="language-php">GET: 200 OK
POST: 201 Created
PUT: 200 OK
PATCH: 200 OK
DELETE: 204 No Content
</code></pre>
<pre><code>//2xx
200 OK - 对成功的 GET、PUT、PATCH 或 DELETE 操作进行
响应。也可以被用在不创建新资源的 POST 操作上
201 Created - 对创建新资源的 POST 操作进行响应。应该带
着指向新资源地址的 Location 头
202 Accepted - 服务器接受了请求，但是还未处理，响应中应
该包含相应的指示信息，告诉客户端该去哪里查询关于本次请
求的信息
204 No Content - 对不会返回响应体的成功请求进行响应（比
如 DELETE 请求）
//3xx
304 Not Modified - HTTP缓存header生效的时候用
// 4xx
400 Bad Request - 请求异常，比如请求中的body无法解析
401 Unauthorized - 没有进行认证或者认证非法
403 Forbidden - 服务器已经理解请求，但是拒绝执行它
404 Not Found - 请求一个不存在的资源
405 Method Not Allowed - 所请求的 HTTP 方法不允许当前认证用户访问
410 Gone - 表示当前请求的资源不再可用。当调用老版本 API的时候很有用
415 Unsupported Media Type - 如果请求中的内容类型是错误的
422 Unprocessable Entity - 用来表示校验错误
429 Too Many Requests - 由于请求频次达到上限而被拒绝访问
//5xx
5xx 状态码表示服务端错误. 一般来说,API不会向用户透露服务器的详细信息,所以只要两个状态码就够了
500 Internal Server Error：客户端请求有效，服务器处理时发生了意外。
503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态。
</code></pre>
<h3 id="数据响应格式">数据响应格式</h3>
<h3 id="调用频率限制">调用频率限制</h3>
<p>为了防止服务器被攻击，减少服务器压力，需要对接口进行合适的限流控制，需要在响应头信息中加入合适的信息，告知客户端当前的限流情况</p>
<pre><code>X-RateLimit-Limit :100 最大访问次数
X-RateLimit-Remaining :93 剩余的访问次数
X-RateLimit-Reset :1513784506 到该时间点，访问次数会重置
为 X-RateLimit-Limit
</code></pre>
<h3 id="接口关联">接口关联</h3>
<blockquote>
<p>做接口的思路与我们做网页应用不同，网站中处理验证码，通常是存入 session，注册的时候验证用户输入的验证码与 session 中的验证码是否相同。但是接口是无状态，相互独立的，处理这种相互关联，有先后调用顺序的接口时，常常是第一个接口返回一个随机的 key，利用这个 key 去调用第二个接口。</p>
</blockquote>
<h2 id="dingoapi">dingo/api</h2>
<p>组件名:<code>dingo/api</code></p>
<h3 id="常用配置">常用配置</h3>
<pre><code class="language-php">#有三个配置项  x 本地开发的或私有环境 prs 提供给公司app,单页面等 vnd 对外发布的,开放给所有用户
API_STANDARDS_TREE=prs
#项目简称
APISUBTYPE=larabbs
#项目前缀或子域名, www.larabbs.com/api
API_PREFIX=api
#api.larabbs.com
API_DOMAIN=api.larabbs.com   
API_DEBUG=true
API_VERSION=v1
#严格模式
APISTRICT=false
</code></pre>
<h4 id="访问不同版本的接口方法">访问不同版本的接口方法</h4>
<p>访问 v1 版本<br>
Accept: application/prs.larabbs.v1+json<br>
访问 v2 版本<br>
Accept: application/prs.larabbs.v2+json</p>
<h3 id="api认证">API认证</h3>
<h3 id="include机制">include机制</h3>
<blockquote>
<p>场景: 获取帖子的作者和栏目信息</p>
</blockquote>
<h4 id="步骤">步骤</h4>
<ol>
<li>在transformer中定义方法</li>
</ol>
<pre><code class="language-php">       //
       protected $availableIncludes=['user','category'];
       //Topic模型中必须有user()方法
       public function includeUser(Topic $topic){
           return $this-&gt;item($topic-&gt;user,new UserTransformer());
       }
</code></pre>
<h4 id="定义">定义</h4>
<pre><code class="language-php">class TopicTransformer extends TransformerAbstract
{
    protected $availableIncludes=['user','category'];

    public function transform(Topic $topic)
    {
		.......
    }

    public function includeUser(Topic $topic){
        return $this-&gt;item($topic-&gt;user,new UserTransformer());
    }

    public function includeCategory(Topic $topic){
        return $this-&gt;item($topic-&gt;category,new CategoryTransformer());
    }
}
</code></pre>
<h4 id="使用">使用:</h4>
<figure data-type="image" tabindex="1"><img src="assets%5C1562034971827.png" alt="1562034971827" loading="lazy"></figure>
<p>调用多个include 将参数写成: xxx.com/api/topics?include=user,category</p>
<p>遇到复杂的嵌套关系可以手动关闭dingo的预加载</p>
<p>app(\Dingo\Api\Transformer\Factory::class)-&gt;disableEagerLoading();</p>
<h4 id="include嵌套">include嵌套</h4>
<p><code>user.roles</code></p>
<figure data-type="image" tabindex="2"><img src="assets%5C1562141101676.png" alt="1562141101676" loading="lazy"></figure>
<h2 id="短信发送">短信发送</h2>
<p>组件 : <code>overtrue/easy-sms</code></p>
<h3 id="easy-sms-组件封装">easy-sms 组件封装</h3>
<h4 id="1创建config文件">1.创建config文件</h4>
<p>config/easysms.php</p>
<pre><code class="language-php">return [
    // HTTP 请求的超时时间（秒）
    'timeout' =&gt; 5.0,
    // 默认发送配置
    'default' =&gt; [
        // 网关调用策略，默认：顺序调用
        'strategy' =&gt; \Overtrue\EasySms\Strategies\OrderStrategy::class,
        // 默认可用的发送网关
        'gateways' =&gt; [
            'yunpian'
        ],
    ],
    // 可用的网关配置
    'gateways' =&gt; [
        'errorlog' =&gt; [
            'file' =&gt; '/tmp/easy-sms.log',
        ],
        'yunpian' =&gt; [
            'api_key' =&gt; '04d7a301137c06e0dde555b0216e7cfe',
        ],
    ],
];
</code></pre>
<h4 id="2添加服务提供者">2.添加服务提供者</h4>
<p>app/providers/EasySmsServiceProvider.php</p>
<pre><code class="language-php">public function boot()
{
    $this-&gt;app-&gt;singleton(EasySms::class,function($app){
        return new EasySms(config('easysms'));
    });
    //设置别名
    $this-&gt;app-&gt;alias(EasySms::class,'easysms');
}
</code></pre>
<blockquote>
<p>在 config/app.php 的provides函数中注册服务提供者</p>
</blockquote>
<h4 id="3发送简单代码">3.发送简单代码</h4>
<pre><code class="language-php">$sms = app('easysms');
try{
$sms-&gt;send(15548551950, [
//这里必须和短信模板严格匹配
'content'  =&gt; '【杨晓光】你的验证码是12343。如非本人操作请忽略',
]);
}catch (\Overtrue\EasySms\Exceptions\NoGatewayAvailableException $e){
$message=$e-&gt;getException('yunpian')-&gt;getMessage();
dd($message);
}
</code></pre>
<h3 id="短信发送涉及知识点">短信发送涉及知识点</h3>
<blockquote>
<p>str_pad()</p>
<p>random_int()</p>
<p>hash_equals() 字符串比较,防止时序攻击</p>
</blockquote>
<h2 id="接口验证码">接口验证码</h2>
<p>插件名称: <code>gregwar/captcha</code></p>
<h3 id="简单实用案例">简单实用案例</h3>
<pre><code class="language-php">//生成验证码
$builder=new CaptchaBuilder();
$captcha=$builder-&gt;build();
//生成图片显示地址
$captch-&gt;inline();
//获取图片验证码的值
$captch-&gt;getPhrase();
</code></pre>
<h2 id="oauth登录">OAUTH登录</h2>
<h3 id="oauth20基础">OAUTH2.0基础</h3>
<h4 id="授权模式">授权模式</h4>
<p>参考文章:<a href="https://learnku.com/articles/20082">oaut图解</a></p>
<ol>
<li>授权码模式</li>
<li>简化模式</li>
<li>密码模式</li>
<li>客户端模式</li>
</ol>
<h3 id="socialite-providers">Socialite Providers</h3>
<p>插件: <a href="https://socialiteproviders.netlify.com/">Socialite Providers     </a></p>
<p>插件扩展: https://socialiteproviders.netlify.com/about.html</p>
<h4 id="登录的两种方式">登录的两种方式</h4>
<ol>
<li><strong>客户端保存accessToken</strong></li>
</ol>
<pre><code class="language-php">$accessToken = 'ACCESS_TOKEN';
$openID = 'OPEN_ID';
$driver = Socialite::driver('weixin');
$driver-&gt;setOpenId($openID);
$oauthUser = $driver-&gt;userFromToken($accessToken);
</code></pre>
<ol start="2">
<li><strong>客户端只获取授权码(code)</strong></li>
</ol>
<blockquote>
<p>这种方式是推荐的安全做法, 客户端不保存app_secrect ,获取到code之后交给服务器换取access_token以及取用用户信息.</p>
</blockquote>
<p>config/services.php</p>
<pre><code class="language-php">'weixin' =&gt; [
    'client_id' =&gt; env('WEIXIN_KEY'),
    'client_secret' =&gt; env('WEIXIN_SECRET'),
    'redirect' =&gt; env('WENXIN_REBACK_URL'),
]
</code></pre>
<pre><code class="language-php">$code = 'CODE';
$driver = Socialite::driver('weixin');
$response = $driver-&gt;getAccessTokenResponse($code);
//微信需要传递openid
$driver-&gt;setOpenId($response['openid']);
$oauthUser = $driver-&gt;userFromToken($response['access_token']);
</code></pre>
<h4 id="oauth注册的两种情况">oauth注册的两种情况</h4>
<ol>
<li>
<p>用户第一次使用微信登录，根据微信的数据，在 项目中创 建一个用户，返回该用户的登录凭证</p>
</li>
<li>
<p>用户已经使用过微信登录，则找到数据库中对应的用户，返回 该用户的登录凭证</p>
</li>
</ol>
<pre><code class="language-php">   路由: $api-&gt;post('socials/{social_type}/authorizations', &quot;AuthorizationsController@weiXinLogin&quot;)-&gt;name('api.socials.authorizations.store');
   public function weiXinLogin($type, AuthorizationsRequest $request)
   {
       if (!in_array($type, ['weixin'])) {
           return $this-&gt;response-&gt;errorBadRequest();
       }
       $driver = \Socialite::driver($type);
       try {
           /*如果传递是code*/
           if ($code = $request-&gt;code) {
               $response = $driver-&gt;getAccessTokenResponse($code);
               $token = array_get($response, 'access_token');
           } else {
               $token = $request-&gt;access_token;
               if ($type == 'weixin') {
                   $driver-&gt;setOpenId($request-&gt;openid);
               }
           }
           $oauthUser = $driver-&gt;userFromToken($token);
       } catch (\Exception $e) {
           return $this-&gt;response-&gt;errorUnauthorized('参数错误');
       }
       /*根据获取的用户信息,去数据库中查找,如果存在则将查询结果返回,否则新建数据并返回*/
       switch ($type) {
           case 'weixin':
               $unionid = $oauthUser-&gt;offsetExists('unionid') ? $oauthUser-&gt;offsetGet('unionid') : null;
               if ($unionid) {
                   /*如果有unionid则用unionid查询,否则用openid查询*/
                   $user = User::where('weixin_unionid', $unionid)-&gt;first();
               } else {
                   $user = User::where('weixin_openid', $oauthUser-&gt;getId())-&gt;first();
               }
               if (!$user) {
                   $user = User::create([
                       'name' =&gt; $oauthUser-&gt;getNickname(),
                       'avatar' =&gt; $oauthUser-&gt;getAvatar(),
                       'wenxin_opeinid' =&gt; $oauthUser-&gt;getId(),
                       'weixin_unionid' =&gt; $unionid,
                   ]);
               }
               break;
       }
       //这里临时先返回id值
       $token = \Auth::guard('api')-&gt;fromUser($user);
       return $this-&gt;authResult($token)-&gt;setStatusCode(200);
   }
</code></pre>
<h4 id="微信的openid和unionid">微信的openid和unionid</h4>
<p>那么如何来分辨用户是否已存在，就需要一个用户的唯一标识。任何 一个第三方平台，返回的用户信息都会有一个唯一标 识， socialite  已经为我们封装好了，直接使用  $oauthUser&gt;getId()  即可获取，对于微信来说，这个唯一标识叫做 openid .</p>
<p>如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程 序），可通过 unionid 来区分用户的唯一性，因为只要是同一个微 信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程 序），用户的 unionid 是唯一的。换句话说，同一用户，对同一个 微信开放平台下的不同应用，unionid 是相同的。</p>
<h3 id="采坑记录">采坑记录</h3>
<h4 id="获取用户信息错误">获取用户信息错误</h4>
<p>错误提示:</p>
<p><code>GuzzleHttp/Exception/RequestException with message 'cURL error 60: SSL certificate problem: unable to get local issuer certificate (see http://curl.haxx.se/libcurl/c/libcurl-errors.html)'</code></p>
<p>问题解决:</p>
<p>估计和本地的ssl证书有关系,远程的暂未测试</p>
<pre><code class="language-php">1. Download the latest cacert.pem from https://curl.haxx.se/ca/cacert.pem
2. Add the following line to php.ini:
curl.cainfo=&quot;/path/to/downloaded/cacert.pem&quot;
</code></pre>
<h2 id="jwt">JWT</h2>
<h3 id="项目入门">项目入门</h3>
<p><code>tymondesigns/jwt-auth</code></p>
<p>项目文档: <a href="https://jwt-auth.readthedocs.io/en/develop/">https://jwt-auth.readthedocs.io/en/develop/</a></p>
<h3 id="部署和配置">部署和配置</h3>
<p>配置项jwt.php</p>
<pre><code class="language-php">//生成的密匙
'secret' =&gt; env('JWT_SECRET'),
//token过期时间
'ttl' =&gt; env('JWT_TTL', 60),
//刷新过期时间,刷新过期时间一般比token时间长,在刷新过期时间,即使token过期,任然可以获取一个新的token,不需要重新登录                                         
 'refresh_ttl' =&gt; env('JWT_REFRESH_TTL', 20160),
</code></pre>
<p>配置config/auth.php</p>
<pre><code class="language-php">guards' =&gt; [ 
    'api' =&gt; [ 
        'driver' =&gt; 'jwt', 
        'provider' =&gt; 'users', 
    ], 
],
</code></pre>
<p>配置config/api.php</p>
<pre><code class="language-php">'auth' =&gt; [ 
    'jwt' =&gt; 'Dingo\Api\Auth\Provider\JWT', 
], 
</code></pre>
<p>配置user模型</p>
<pre><code class="language-php">class User extends Authenticatable implements JWTSubject 
 
    public function getJWTIdentifier() 
    { 
        return $this-&gt;getKey(); 
    } 
 
    public function getJWTCustomClaims() 
    { 
        return [];
    }
</code></pre>
<h3 id="常用方法">常用方法</h3>
<h4 id="token生成">token生成</h4>
<pre><code class="language-php">//基于账号密码生成token
$credentials=request(['email','password']);
auth('api')-&gt;attempt($credentials);
//基于用户模型生成token
$user=User::first();
auth('api')-&gt;fromUser($user);
//基于users模型中的主键id
auth('api')-&gt;tokenById(1);
</code></pre>
<h4 id="token解析">token解析</h4>
<pre><code class="language-php">//把请求发送过来的直接解析到对象
JWTAuth::parseToken();
//获取token中的user信息
auth('api')-&gt;user();
//获取token,如果token被设置则返回,否则返回false
auth('api')-&gt;getToken();
</code></pre>
<h4 id="token控制">token控制</h4>
<pre><code class="language-php">//更新token
$token=auth('api')-&gt;refresh();
//让一个token无效
auth('api')-&gt;invalidate();
//检验token的有效性
auth('api')-&gt;check();

</code></pre>
<h4 id="token其他方法">token其他方法</h4>
<pre><code class="language-php">//设置荷载
$token=auth('api')-&gt;claims(['foo'=&gt;'bar'])-&gt;attempt($credentials);
//重写有效时间
auth('api')-&gt;setTTL(7200)-&gt;attempt($credentials);
//验证账号是否正确
auth('api')-&gt;validate($credentials);
</code></pre>
<h3 id="使用案例">使用案例</h3>
<ol>
<li>composer 安装</li>
</ol>
<pre><code class="language-php">composer require tymon/jwt-auth 1.*@rc
</code></pre>
<blockquote>
<p>通过该命令安装的可能为0.5.*版本,执行composer update命令进行升级版本或者直接指定版本号</p>
</blockquote>
<ol start="2">
<li>生成密匙</li>
</ol>
<p><code>php artisan jwt:secret</code></p>
<ol start="3">
<li>修改config/auth.php</li>
</ol>
<pre><code class="language-php">'guards' =&gt; [
    'api' =&gt; [
        'driver' =&gt; 'jwt',
        'provider' =&gt; 'users',
    ],
]
</code></pre>
<ol start="4">
<li>修改 config/api.php</li>
</ol>
<pre><code class="language-php">'auth' =&gt; [
    'jwt'=&gt;'Dingo\Api\Auth\Provider\JWT',
],
</code></pre>
<ol start="5">
<li>修改user.php模型</li>
</ol>
<p>让user.php 实现use Tymon\JWTAuth\Contracts\JWTSubject;</p>
<pre><code class="language-php">class User extends Authenticatable implements JWTSubject
{
        //这里返回了User的id
    public function getJWTIdentifier()
    {
        return $this-&gt;getKey();
    }

    //这里是我们需要额外在jwt中增加的自定义内容
    public function getJWTCustomClaims()
    {
        return [];
    }
}
</code></pre>
<ol start="6">
<li>注册provide和alias<br>
<code>config/app.php</code></li>
</ol>
<pre><code class="language-php">   'aliases'=&gt;[
       'JWTAuth'=&gt;'Tymon\JWTAuth\Facades\JWTAuth',
       'JWTFactory'=&gt;'Tymon\JWTAuth\Facades\JWTFactory'
   ]
</code></pre>
<blockquote>
<p>如果你不适用这两个Facade,你可以使用辅助函数auth()</p>
</blockquote>
<p>auth辅助函数与jwt扩展</p>
<ol start="7">
<li>
<p>jwt的几种常用操作<br>
路由</p>
<pre><code class="language-php">//登录
Route::post('login','AuthController@login');
//注销token
Route::delete('logout','AuthController@logout');
//刷新token
Route::put('refresh','AuthController@refresh');
//获取信息
Route::post('me','AuthController@me');
</code></pre>
<p>控制器</p>
</li>
</ol>
<pre><code class="language-php">   public function store(AuthRequest $request)
   {
       //传入两个参数username,password.这里username 可能有是邮箱或者电话,需要判断一下
       $username = $request-&gt;username;
       filter_var($username, FILTER_VALIDATE_EMAIL) ? $credentials['email'] = $username : $credentials['phone'] = $username;
       $credentials['password'] = $request-&gt;password;
       $token = \Auth::guard('api')-&gt;attempt($credentials);
       if (!$token) {
           return $this-&gt;response-&gt;errorUnauthorized('用户名密码不正确');
       }
       //这里定义一个通用的返回信息函数
       return $this-&gt;authResult($token)-&gt;setStatusCode(200);
   }
   
   /**微信oauth 登录
        * @param $type 路由中的第三方登录类型参数,如weixin
        * @param AuthorizationsRequest $request
        */
   public function weiXinLogin($type, AuthorizationsRequest $request)
   {
       if (!in_array($type, ['weixin'])) {
           return $this-&gt;response-&gt;errorBadRequest();
       }
       $driver = \Socialite::driver($type);
       try {
           /*如果传递是code*/
           if ($code = $request-&gt;code) {
               $response = $driver-&gt;getAccessTokenResponse($code);
               $token = array_get($response, 'access_token');
           } else {
               $token = $request-&gt;access_token;
               if ($type == 'weixin') {
                   $driver-&gt;setOpenId($request-&gt;openid);
               }
           }
           $oauthUser = $driver-&gt;userFromToken($token);
       } catch (\Exception $e) {
           return $this-&gt;response-&gt;errorUnauthorized('参数错误');
       }
       /*根据获取的用户信息,去数据库中查找,如果存在则将查询结果返回,否则新建数据并返回*/
       switch ($type) {
           case 'weixin':
               $unionid = $oauthUser-&gt;offsetExists('unionid') ? $oauthUser-&gt;offsetGet('unionid') : null;
               if ($unionid) {
                   /*如果有unionid则用unionid查询,否则用openid查询*/
                   $user = User::where('weixin_unionid', $unionid)-&gt;first();
               } else {
                   $user = User::where('weixin_openid', $oauthUser-&gt;getId())-&gt;first();
               }
               if (!$user) {
                   $user = User::create([
                       'name' =&gt; $oauthUser-&gt;getNickname(),
                       'avatar' =&gt; $oauthUser-&gt;getAvatar(),
                       'wenxin_opeinid' =&gt; $oauthUser-&gt;getId(),
                       'weixin_unionid' =&gt; $unionid,
                   ]);
               }
               break;
       }
       //这里临时先返回id值
       $token = \Auth::guard('api')-&gt;fromUser($user);
       return $this-&gt;authResult($token)-&gt;setStatusCode(200);
   }
   
   public function refresh()
   {
       $token=\Auth::guard('api')-&gt;refresh();
       return $this-&gt;authResult($token)-&gt;setStatusCode(200);
   }
   
   public function destroy()
   {
       \Auth::guard('api')-&gt;logout();
       //noContent 返回的状态码 204
       return $this-&gt;response-&gt;noContent();
   }
   
   protected function authResult($token)
   {
       return $this-&gt;response-&gt;array([
           'access_token' =&gt; $token,
           'token_type' =&gt; 'Bearer',
           'expires_in' =&gt; \Auth::guard('api')-&gt;factory()-&gt;getTTL() * 60
       ]);
   }
</code></pre>
<blockquote>
<p>refresh() token 刷新 destroy 销毁 都需要携带 Authorization:Bear  {token}</p>
</blockquote>
<h2 id="transformers">Transformers</h2>
<blockquote>
<p>通过转化器, 你可以将对象转化为数组, 并强制转化整型和布尔类型, 包括分页结果和嵌套关联.</p>
</blockquote>
<h3 id="fractal">Fractal</h3>
<p>Dingo API 底层使用 <a href="https://github.com/thephpleague/fractal">Fractal</a> 作为默认的转化层</p>
<p>Fractal 的意义在原始数据和输出数据中间搞一个墙('barrier'), 这样的话即使内部结构改变了也不会影响到用户</p>
<h4 id="资源分类">资源分类:</h4>
<ul>
<li><code>League\Fractal\Resource\Item</code>：单个资源</li>
<li><code>League\Fractal\Resource\Collection</code>：资源集合</li>
</ul>
<h4 id="简单案例">简单案例</h4>
<pre><code class="language-php">Route::get('/fractal/resource/collection', function () {
    $tasks = \App\Task::all();
    $resource = new \League\Fractal\Resource\Collection($tasks, function (\App\Task $task) {
        return [
            'id' =&gt; $task-&gt;id,
            'text' =&gt; $task-&gt;text,
            'is_completed' =&gt; $task-&gt;is_completed ? 'yes' : 'no'
        ];
    });
    //Manager,主要管理要将数据格式化为哪一种格式
    $fractal = new \League\Fractal\Manager();
    return $fractal-&gt;createData($resource)-&gt;toJson();
});
</code></pre>
<h4 id="三种数据结构">三种数据结构</h4>
<p><code>ArraySerializer</code>、<code>DataArraySerializer</code>、<code>JsonApiSerializer</code>三种序列化器</p>
<ol>
<li><code>ArraySerializer</code></li>
</ol>
<pre><code class="language-php">Route::get('/fractal/serializers', function () {
    $task = \App\Task::findOrFail(1);
    $resource = new \League\Fractal\Resource\Item($task, function (\App\Task $task) {
        return [
            'id' =&gt; $task-&gt;id,
            'text' =&gt; $task-&gt;text,
            'is_completed' =&gt; $task-&gt;is_completed ? 'yes' : 'no'
        ];
    });
    $fractal = new \League\Fractal\Manager();
    $fractal-&gt;setSerializer(new \League\Fractal\Serializer\ArraySerializer());
    return $fractal-&gt;createData($resource)-&gt;toJson();
});
</code></pre>
<figure data-type="image" tabindex="3"><img src="assets/1558154981808.png" alt="1558154981808" loading="lazy"></figure>
<ol start="2">
<li>
<p><code>DataArraySerializer</code></p>
<blockquote>
<p>DataArraySerializer 是Fractal默然的数据输出格式,与ArraySerializer相比,多出了一层data包裹</p>
</blockquote>
</li>
</ol>
<pre><code class="language-php">$fractal-&gt;setSerializer(new \League\Fractal\Serializer\DataArraySerializer());
</code></pre>
<figure data-type="image" tabindex="4"><img src="assets/1558155166061.png" alt="1558155166061" loading="lazy"></figure>
<ol start="3">
<li>
<p><code>JsonApiSerializer</code></p>
<pre><code class="language-php">$fractal-&gt;setSerializer(new \League\Fractal\Serializer\JsonApiSerializer());
</code></pre>
<figure data-type="image" tabindex="5"><img src="assets/1558155367779.png" alt="1558155367779" loading="lazy"></figure>
</li>
</ol>
<h4 id="转换器">转换器</h4>
<blockquote>
<p>转化器类必须继承自 <code>League\Fractal\TransformerAbstract</code> 基类，并且至少实现 <code>transform()</code> 方法。我们在代码任务项目中创建一个保存在 <code>app/Transformers</code> 目录下的转化器类 <code>TaskTransformer</code>，并初始化代码如下</p>
</blockquote>
<pre><code class="language-php">&lt;?php
namespace App\Transformers;
use App\Task;
use League\Fractal\TransformerAbstract;

class TaskTransformer extends TransformerAbstract
{
    public function transform(Task $task)
    {
        return [
            'id' =&gt; $task-&gt;id,
            'text' =&gt; $task-&gt;text,
            //需要注意一些敏感信息,如用户手机,微信的union_id等,我们可以使用另外的字段返回
            'phone'=&gt;$task-&gt;phone?true:false,
            'completed' =&gt; $task-&gt;is_completed ? 'yes' : 'no',
            'link' =&gt; route('tasks.show', ['id' =&gt; $task-&gt;id])
        ];
    }
}
</code></pre>
<p>这样一来，我们就可以改写之前的资源转化代码如下：</p>
<pre><code class="language-php">// 获取单个资源
$task = \App\Task::findOrFail(1);
$resource = new \League\Fractal\Resource\Item($task, new \App\Transformers\TaskTransformer());

// 获取资源集合
$tasks = \App\Task::all();
$resources = new \League\Fractal\Resource\Collection($tasks, new \App\Transformers\TaskTransformer());
</code></pre>
<p><strong>关联模型数据</strong></p>
<p>除此之外，我们还可以在模型字段之外，引入额外的数据，比如关联模型：</p>
<pre><code>&lt;?php

namespace App\Transformers;

use App\Task;
use League\Fractal\TransformerAbstract;

class TaskTransformer extends TransformerAbstract
{
    protected $availableIncludes = ['user'];

    public function transform(Task $task)
    {
        return [
            'id' =&gt; $task-&gt;id,
            'text' =&gt; $task-&gt;text,
            'completed' =&gt; $task-&gt;is_completed ? 'yes' : 'no',
            'link' =&gt; route('tasks.show', ['id' =&gt; $task-&gt;id])
        ];
    }

    public function includeUser(Task $task)
    {
        $user = $task-&gt;user;
        return $this-&gt;item($user, new UserTransformer());
    }
}
</code></pre>
<p>由于在上述代码中引入了新的转化器类 <code>UserTransformer</code>，所以需要创建它：</p>
<pre><code>&lt;?php

namespace App\Transformers;

use App\User;
use League\Fractal\TransformerAbstract;

class UserTransformer extends TransformerAbstract
{
    public function transform(User $user)
    {
        return [
            'id' =&gt; $user-&gt;id,
            'name' =&gt; $user-&gt;name
        ];
    }
}
</code></pre>
<p>然后修改返回响应数据代码如下，通过 <code>parseIncludes</code> 方法引入要包含的额外字段：</p>
<pre><code>return $fractal-&gt;parseIncludes('user')-&gt;createData($resource)-&gt;toJson();
</code></pre>
<p>这样一来，就可以在返回的响应数据中看到 <code>user</code> 字段了：</p>
<figure data-type="image" tabindex="6"><img src="assets/546fc78b6e238ab7558082109660f566.jpg" alt="img" loading="lazy"></figure>
<h3 id="数据格式切换组件">数据格式切换组件</h3>
<h4 id="名称-liyu001989dingo-serializer-switch">名称: <a href="https://github.com/liyu001989">liyu001989</a>/<strong>dingo-serializer-switch</strong></h4>
<blockquote>
<p>参考一下该组件,做laravel的扩展组件</p>
</blockquote>
<h4 id="使用-2">使用</h4>
<pre><code class="language-php">//routes/api.php
$api-&gt;version('v1',['middleware'=&gt;'serialize:array'])
</code></pre>
<h2 id="http基础">HTTP基础</h2>
<h3 id="http-提交数据的两种方式">http 提交数据的两种方式</h3>
<p>application/x-www-form-urlencoded(默认值)<br>
multipart/form-data</p>
<p>需要明确的是，只有当 POST 配合  multipart/form-data  时才能正<br>
确传输文件。</p>
<h2 id="帖子数据">帖子数据</h2>
<h3 id="修改话题">修改话题</h3>
<pre><code class="language-php">//修改话题
$api-&gt;patch('topics/{topic}','TopicsController@update')-&gt;name('api.topics.update');
</code></pre>
<blockquote>
<p>这里需要注意的是由于路由交给DingoApi来处理了,所以调至路由模型绑定出了问题.所以模型绑定的中间件没有注册上,需要手动增加bindings中间件</p>
</blockquote>
<pre><code class="language-php">$api-&gt;version('v1', [
    'namespace' =&gt; 'App\Http\Controllers\Api',
    //这里增加bindings
    'middleware' =&gt; ['serializer:array','bindings']
])
</code></pre>
<h4 id="dingoapi手动处理异常">dingoApi手动处理异常</h4>
<pre><code class="language-php">//app/Providers/AppServiceProvider.php
</code></pre>
<pre><code class="language-php">public function register()
{
    \API::error(function (\Illuminate\Auth\Access\AuthorizationException $exception) {
        abort(403, $exception-&gt;getMessage());
    });
    \API::error(function  (\Symfony\Component\HttpKernel\Exception\NotFoundHttpException  $exception)  {
        throw  new  \Symfony\Component\HttpKernel\Exception\HttpException(404,  '404 Not Found');
    });
}
</code></pre>
<h3 id="日志查询组件">日志查询组件</h3>
<p><code>laravel-query-logger</code></p>
<h4 id="安装">安装</h4>
<pre><code class="language-php">composer require overtrue/laravel-query-logger --dev
</code></pre>
<blockquote>
<p>只有当APP_DEBUG为true 时才能使用</p>
</blockquote>
<h2 id="消息接口">消息接口</h2>
<h2 id="本地化">本地化</h2>
<h3 id="思路1">思路1:</h3>
<p>增加自定义code码</p>
<pre><code class="language-php">use Symfony\Component\HttpKernel\Exception\HttpException;

class Controller extends BaseController
{
    //引入dingo的部分方法
    use Helpers;
	//自定义异常处理
    public function errorResponse($statusCode,$message=null,$code=0)
    {
        throw new HttpException($statusCode,$message,null,[],$code);
    }
}
</code></pre>
<h3 id="思路2">思路2:</h3>
<blockquote>
<p>利用HTTP的Accept-language 头信息</p>
<p>Accept-Language zh-CN	简体中文</p>
<p>Accept-Language en 英文</p>
</blockquote>
<h4 id="步骤-2">步骤:</h4>
<ol>
<li><strong>创建编辑中间件changeLocale</strong></li>
</ol>
<pre><code class="language-php">class ChangeLocale
{
    public function handle($request, Closure $next)
    {
        $language=$request-&gt;header('accept-language');
        if($language){
            \App::setLocale($language);
        }
        return $next($request);
    }
}
</code></pre>
<ol start="2">
<li>
<p><strong>注册中间件</strong></p>
<p><code>app/Http/Kernel.php</code></p>
</li>
</ol>
<pre><code class="language-php">'change-locale'=&gt;\App\Http\Middleware\ChangeLocale::class,
</code></pre>
<ol start="3">
<li><strong>路由设置中间件</strong></li>
</ol>
<pre><code class="language-php">$api-&gt;version('v1', [
    'namespace' =&gt; 'App\Http\Controllers\Api',
    'middleware' =&gt; ['serializer:array','bindings','change-locale']
]
</code></pre>
<ol start="4">
<li>使用案例</li>
</ol>
<pre><code class="language-php">if (!$token = \Auth::guard('api')-&gt;attempt($credentials)) {
	return $this-&gt;response-&gt;errorUnauthorized(trans('auth.failed'));
}
</code></pre>
<h2 id="api测试和文档">API测试和文档</h2>
<h3 id="phpunit-测试">phpunit 测试</h3>
<h4 id="windows下安装">windows下安装</h4>
<blockquote>
<p>虽然laravel框架内置了phpunit,但是不能使用,直接在项目中输入phpunit 会显示 command not found</p>
</blockquote>
<ol>
<li>
<p>删除vendor 文件夹,然后重新composer update</p>
</li>
<li>
<p>输入以下命令引入phpunit包</p>
<pre><code class="language-php">$ composer global require phpunit/phpunit
</code></pre>
<p><code>omposer global remove phpunit/phpunit</code> phpunit包的删除命令</p>
</li>
<li>
<p>配置环境变量</p>
<p>phpunit命令的存放目录: D:\wamp64\www\question_bank\vendor\bin</p>
</li>
</ol>
<h4 id="单元测试">单元测试</h4>
<ol>
<li>创建测试文件</li>
</ol>
<pre><code class="language-php">php artisan make:test TopicApiTest
</code></pre>
<p>该命令会在tests/Feature目录中创建TopicApiTest.php文件</p>
<ol start="2">
<li>测试发布话题</li>
</ol>
<pre><code class="language-php">       //setUp方法在测试开始前执行,先创建一个用户
   public function setUp(): void
       {
           parent::setUp(); // TODO: Change the autogenerated stub
           $this-&gt;user = factory(User::class)-&gt;create();
       }
   
       public function testStoreTopic()
       {
           $data = ['category_id' =&gt; 1, 'body' =&gt; 'test body', 'title' =&gt; 'test title'];
           $token=\Auth::guard('api')-&gt;fromUser($this-&gt;user);
           //$this-&gt;json可以方便的模拟各种http请求,第一个参数:请求的方法,第二个参数:请求地址,第三个参数:请求参数,第四个参数:请求header,利用withHeaders方法也可以
           $response=$this-&gt;withHeaders(['Authorization'=&gt;'Bearer'.$token])-&gt;json('POST','/api/topics',$data);
   
           $assertData = [
               'category_id' =&gt; 1,
               'user_id' =&gt; $this-&gt;user-&gt;id,
               'title' =&gt; 'test title',
               'body' =&gt; clean('test body', 'user_topic_body')
           ];
           //通过assertStatus,断言响应结果为201，通过assertJsonFragment,断言响应结果包含assertData数据。
           $response-&gt;assertStatus(201)-&gt;assertJsonFragment($assertData);
       }
</code></pre>
<ol start="3">
<li>
<p>执行测试</p>
<pre><code class="language-php">$ phpunit
</code></pre>
</li>
</ol>
<h3 id="第三方黑盒测试-postman">第三方黑盒测试 [postman]</h3>
<ol>
<li>
<p>导出导入collections和环境变量</p>
</li>
<li>
<p>编写测试用例</p>
</li>
</ol>
<figure data-type="image" tabindex="7"><img src="E:%5CNutCloud%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Claravel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cassets%5C1562227821519.png" alt="1562227821519" loading="lazy"></figure>
<ol start="3">
<li>批量测试</li>
</ol>
<h3 id="api-文档">api 文档</h3>
<p><a href="https://apizza.net/">https://apizza.net</a></p>
<h2 id="passport使用">passport使用</h2>
<h3 id="安装和设置">安装和设置</h3>
<p>1.composer 安装</p>
<pre><code class="language-php">composer require laravel/passport
</code></pre>
<p>2.生成数据表<br>
<code>migrate</code></p>
<ol start="3">
<li>创建加密秘匙</li>
</ol>
<pre><code class="language-php">php artisan passport:keys
</code></pre>
<ol start="4">
<li>创建客户端</li>
</ol>
<pre><code class="language-php">php artisan passport:client --password --name='larabbs-ios'
</code></pre>
<h3 id="passport调试">passport调试</h3>
<h4 id="1注册路由">1.注册路由</h4>
<p>app/Providers/AuthServiceProvider.php</p>
<pre><code class="language-php">    public function boot()
    {
        //Passport的路由
        Passport::routes();
        //access_token过期时间
        Passport::tokensExpireIn(Carbon::now()-&gt;addDays(15));
        //refreshTokens 刷星过期时间
        Passport::refreshTokensExpireIn(Carbon::now()-&gt;addDays(30));
</code></pre>
<h4 id="2-获取访问令牌">2. 获取访问令牌</h4>
<p><img src="assets/20190705164343875_11189.png" alt="" loading="lazy"><br>
<strong>参数列表</strong><br>
grant_type —— 密码模式固定为    password  ；<br>
client_id —— 通过    passport:client   创建的客户端  id  ；<br>
client_secret —— 通过    passport:client   创建的客户端  secret  ；<br>
username —— 登录的用户名，数据库中任意用户邮箱；<br>
password —— 用户密码；<br>
scope —— 作用域，可填写    *   或者为空；<br>
<strong>获取的信息</strong><br>
token_type —— 令牌类型；<br>
expires_in—— 多长时间后过期；<br>
access_token —— 访问令牌；<br>
refresh_token —— 刷新令牌；<br>
<img src="assets/20190705164603055_29633.png" alt="" width="593" loading="lazy"></p>
<h4 id="获取登录用户信息">获取登录用户信息</h4>
<p>1.修改user模型 添加  Laravel\Passport\HasApiTokens   Trait<br>
2.修改auth配置,将api guard的driver由jwt 修改为passport<br>
3.增加一个PassportDingoProvider,因为DingoApi没有做passport的适配.</p>

        </div>
        <!-- Share to Twitter, Weibo, Telegram -->
        <div class="flex items-center">
          <div class="mr-4 flex items-center">
            <i class="ri-share-forward-line text-gray-500"></i>
          </div>
          <div class="px-4 cursor-pointer text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTwitter">
            <i class="ri-twitter-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-red-500 hover:bg-red-100 dark:hover:bg-gray-600 inline-flex" @click="shareToWeibo">
            <i class="ri-weibo-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-indigo-500 hover:bg-indigo-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTelegram">
            <i class="ri-telegram-line"></i>
          </div>
        </div>
      </div>

      

      

      <footer class="py-12 text-center px-4 md:px-0" v-pre>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
</footer>
    </div>

    <!-- TOC Container -->
    <div class="fixed right-0 bottom-0 mb-16 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white dark:bg-gray-500 dark:text-gray-200 hover:shadow-lg transition-all animated fadeInRight" @click="showToc = true">
      <i class="ri-file-list-line"></i>
    </div>

    <div class="fixed right-0 top-0 bottom-0 overflow-y-auto w-64 bg-white dark:bg-gray-800 p-4 border-l border-gray-100 dark:border-gray-600 z-10 transition-fast" :class="{ '-mr-64': !showToc }">
      <div class="flex mb-4 justify-end">
        <div class="w-8 h-8 inline-flex justify-center items-center rounded-full cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 transition-fast" @click="showToc = false">
          <i class="ri-close-line text-lg"></i>
        </div>
      </div>
      <div class="post-toc-container">
        <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%9D%82%E9%A1%B9%E9%97%AE%E9%A2%98">杂项问题</a>
<ul>
<li><a href="#postman-%E5%90%AF%E5%8A%A8%E7%A9%BA%E7%99%BD%E4%BF%AE%E5%A4%8D">postman 启动空白修复</a></li>
<li><a href="#cerbot-%E9%83%A8%E7%BD%B2https">cerbot 部署https</a></li>
<li><a href="#%E5%AE%9D%E5%A1%94%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93">宝塔远程连接数据库</a></li>
</ul>
</li>
<li><a href="#restful%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">RESTful设计原则</a>
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%8A%A8%E8%AF%8D">常用动词</a></li>
<li><a href="#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">版本控制</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E5%91%BD%E5%90%8D">路由命名</a></li>
<li><a href="#%E8%B5%84%E6%BA%90%E8%BF%87%E6%BB%A4">资源过滤</a></li>
<li><a href="#%E7%8A%B6%E6%80%81%E7%A0%81">状态码</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E6%A0%BC%E5%BC%8F">数据响应格式</a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E9%A2%91%E7%8E%87%E9%99%90%E5%88%B6">调用频率限制</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3%E5%85%B3%E8%81%94">接口关联</a></li>
</ul>
</li>
<li><a href="#dingoapi">dingo/api</a>
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE">常用配置</a>
<ul>
<li><a href="#%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95">访问不同版本的接口方法</a></li>
</ul>
</li>
<li><a href="#api%E8%AE%A4%E8%AF%81">API认证</a></li>
<li><a href="#include%E6%9C%BA%E5%88%B6">include机制</a>
<ul>
<li><a href="#%E6%AD%A5%E9%AA%A4">步骤</a></li>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8">使用:</a></li>
<li><a href="#include%E5%B5%8C%E5%A5%97">include嵌套</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%9F%AD%E4%BF%A1%E5%8F%91%E9%80%81">短信发送</a>
<ul>
<li><a href="#easy-sms-%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85">easy-sms 组件封装</a>
<ul>
<li><a href="#1%E5%88%9B%E5%BB%BAconfig%E6%96%87%E4%BB%B6">1.创建config文件</a></li>
<li><a href="#2%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85">2.添加服务提供者</a></li>
<li><a href="#3%E5%8F%91%E9%80%81%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81">3.发送简单代码</a></li>
</ul>
</li>
<li><a href="#%E7%9F%AD%E4%BF%A1%E5%8F%91%E9%80%81%E6%B6%89%E5%8F%8A%E7%9F%A5%E8%AF%86%E7%82%B9">短信发送涉及知识点</a></li>
</ul>
</li>
<li><a href="#%E6%8E%A5%E5%8F%A3%E9%AA%8C%E8%AF%81%E7%A0%81">接口验证码</a>
<ul>
<li><a href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8%E6%A1%88%E4%BE%8B">简单实用案例</a></li>
</ul>
</li>
<li><a href="#oauth%E7%99%BB%E5%BD%95">OAUTH登录</a>
<ul>
<li><a href="#oauth20%E5%9F%BA%E7%A1%80">OAUTH2.0基础</a>
<ul>
<li><a href="#%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F">授权模式</a></li>
</ul>
</li>
<li><a href="#socialite-providers">Socialite Providers</a>
<ul>
<li><a href="#%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F">登录的两种方式</a></li>
<li><a href="#oauth%E6%B3%A8%E5%86%8C%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5">oauth注册的两种情况</a></li>
<li><a href="#%E5%BE%AE%E4%BF%A1%E7%9A%84openid%E5%92%8Cunionid">微信的openid和unionid</a></li>
</ul>
</li>
<li><a href="#%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95">采坑记录</a>
<ul>
<li><a href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E9%94%99%E8%AF%AF">获取用户信息错误</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jwt">JWT</a>
<ul>
<li><a href="#%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8">项目入门</a></li>
<li><a href="#%E9%83%A8%E7%BD%B2%E5%92%8C%E9%85%8D%E7%BD%AE">部署和配置</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">常用方法</a>
<ul>
<li><a href="#token%E7%94%9F%E6%88%90">token生成</a></li>
<li><a href="#token%E8%A7%A3%E6%9E%90">token解析</a></li>
<li><a href="#token%E6%8E%A7%E5%88%B6">token控制</a></li>
<li><a href="#token%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95">token其他方法</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B">使用案例</a></li>
</ul>
</li>
<li><a href="#transformers">Transformers</a>
<ul>
<li><a href="#fractal">Fractal</a>
<ul>
<li><a href="#%E8%B5%84%E6%BA%90%E5%88%86%E7%B1%BB">资源分类:</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B">简单案例</a></li>
<li><a href="#%E4%B8%89%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">三种数据结构</a></li>
<li><a href="#%E8%BD%AC%E6%8D%A2%E5%99%A8">转换器</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%88%87%E6%8D%A2%E7%BB%84%E4%BB%B6">数据格式切换组件</a>
<ul>
<li><a href="#%E5%90%8D%E7%A7%B0-liyu001989dingo-serializer-switch">名称: liyu001989/<strong>dingo-serializer-switch</strong></a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-2">使用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#http%E5%9F%BA%E7%A1%80">HTTP基础</a>
<ul>
<li><a href="#http-%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F">http 提交数据的两种方式</a></li>
</ul>
</li>
<li><a href="#%E5%B8%96%E5%AD%90%E6%95%B0%E6%8D%AE">帖子数据</a>
<ul>
<li><a href="#%E4%BF%AE%E6%94%B9%E8%AF%9D%E9%A2%98">修改话题</a>
<ul>
<li><a href="#dingoapi%E6%89%8B%E5%8A%A8%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8">dingoApi手动处理异常</a></li>
</ul>
</li>
<li><a href="#%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2%E7%BB%84%E4%BB%B6">日志查询组件</a>
<ul>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%B6%88%E6%81%AF%E6%8E%A5%E5%8F%A3">消息接口</a></li>
<li><a href="#%E6%9C%AC%E5%9C%B0%E5%8C%96">本地化</a>
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF1">思路1:</a></li>
<li><a href="#%E6%80%9D%E8%B7%AF2">思路2:</a>
<ul>
<li><a href="#%E6%AD%A5%E9%AA%A4-2">步骤:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#api%E6%B5%8B%E8%AF%95%E5%92%8C%E6%96%87%E6%A1%A3">API测试和文档</a>
<ul>
<li><a href="#phpunit-%E6%B5%8B%E8%AF%95">phpunit 测试</a>
<ul>
<li><a href="#windows%E4%B8%8B%E5%AE%89%E8%A3%85">windows下安装</a></li>
<li><a href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95-postman">第三方黑盒测试 [postman]</a></li>
<li><a href="#api-%E6%96%87%E6%A1%A3">api 文档</a></li>
</ul>
</li>
<li><a href="#passport%E4%BD%BF%E7%94%A8">passport使用</a>
<ul>
<li><a href="#%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AE">安装和设置</a></li>
<li><a href="#passport%E8%B0%83%E8%AF%95">passport调试</a>
<ul>
<li><a href="#1%E6%B3%A8%E5%86%8C%E8%B7%AF%E7%94%B1">1.注册路由</a></li>
<li><a href="#2-%E8%8E%B7%E5%8F%96%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C">2. 获取访问令牌</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF">获取登录用户信息</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      </div>
    </div>

    <!-- Back to top -->
    <div class="fixed right-0 bottom-0 mb-4 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white hover:shadow-lg transition-all dark:bg-gray-500 dark:text-gray-200" @click="backToUp" v-show="scrolled">
      <i class="ri-arrow-up-line"></i>
    </div>
  </div>

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
        It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg">
  </div>
  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
    </div>
    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->
        <div class="pswp__counter">
        </div>
        <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
        <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
        <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip">
        </div>
      </div>
      <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
      </button>
      <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
      </button>
      <div class="pswp__caption">
        <div class="pswp__caption__center">
        </div>
      </div>
    </div>
  </div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="https://bluegrasses.github.io/media/scripts/main.js"></script>
  
  <!-- Code Highlight -->
  
    <script src="https://bluegrasses.github.io/media/prism.js"></script>
    <script>
      Prism.highlightAll()
    </script>
  

  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>
  <script>
    //拿到预览框架，也就是上面的html代码
    var pswpElement = document.querySelectorAll('.pswp')[0];
    //定义图片数组变量
    var imgitems;
    /**
    * 用于显示预览界面
    * @param index 图片数组下标
    */
    function viewImg(index) {
      //其它选项这里不做过多阐述，详情见官网
      var pswpoptions = {
        index: parseInt(index, 10), // 开始幻灯片索引。0是第一张幻灯片。必须是整数，而不是字符串。
        bgOpacity: 0.7, // 背景透明度，0-1
        maxSpreadZoom: 3, // 缩放级别，不要太大
      };
      //初始化并打开PhotoSwipe，pswpElement对应上面预览框架，PhotoSwipeUI_Default为皮肤，imgitems为图片数组，pswpoptions为选项
      var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, imgitems, pswpoptions);
      gallery.init()
    }
    /**
    * 用于添加图片点击事件
    * @param img 图片元素
    * @param index 所属下标（在imgitems中的位置）
    */
    function addImgClick(img, index) {
      img.onclick = function() {
        viewImg(index)
      }
    }
    /**
    * 轮询所有图片，获取src、width、height等数据，加入imgitems，并给图片元素添加事件
    * 最好在onload中执行该方法，本站因放在最底部，所以直接初始化
    * 异步加载图片可在图片元素创建完成后调用此方法
    */
    function initImg() {
      //重置图片数组
      imgitems = [];
      //查找class:markdown 下的所有img元素并遍历
      var imgs = document.querySelectorAll('.markdown img');
      for (var i = 0; i < imgs.length; i++) {
        var img = imgs[i];
        //本站相册初始为loading图片，真实图片放在data-src
        var ds = img.getAttribute("data-src");
        //创建image对象，用于获取图片宽高
        var imgtemp = new Image();
        //判断是否存在data-src
        if (ds != null && ds.length > 0) {
          imgtemp.src = ds
        } else {
          imgtemp.src = img.src
        }
        //判断是否存在缓存
        if (imgtemp.complete) {
          var imgobj = {
            "src": imgtemp.src,
            "w": imgtemp.width,
            "h": imgtemp.height,
          };
          imgitems[i] = imgobj;
          addImgClick(img, i);
        } else {
          console.log('进来了2')
          imgtemp.index = i;
          imgtemp.img = img;
          imgtemp.onload = function() {
            var imgobj = {
              "src": this.src,
              "w": this.width,
              "h": this.height,
            };
            //不要使用push，因为onload前后顺序会不同
            imgitems[this.index] = imgobj
            //添加点击事件
            addImgClick(this.img, this.index);
          }
        }
      }
    }
    //初始化
    initImg();
  </script>
  
  
</body>

</html>