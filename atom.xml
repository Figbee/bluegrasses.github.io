<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bluegrasses.github.io</id>
    <title>罗亭的技术博客</title>
    <updated>2020-06-05T11:46:27.933Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bluegrasses.github.io"/>
    <link rel="self" href="https://bluegrasses.github.io/atom.xml"/>
    <subtitle>以梦为马, 诗酒趁年华</subtitle>
    <logo>https://bluegrasses.github.io/images/avatar.png</logo>
    <icon>https://bluegrasses.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 罗亭的技术博客</rights>
    <entry>
        <title type="html"><![CDATA[{go} 标准库之 http]]></title>
        <id>https://bluegrasses.github.io/post/go-biao-zhun-ku-http/</id>
        <link href="https://bluegrasses.github.io/post/go-biao-zhun-ku-http/">
        </link>
        <updated>2020-05-27T02:09:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-http">一.  http</h2>
<h3 id="do">do</h3>
<pre><code class="language-go">client := &amp;http.Client{}
request, err := http.NewRequest(&quot;GET&quot;, &quot;http://www.hoopchina.com&quot;, nil)
resp, err := client.Do(request)
body, err := ioutil.ReadAll(resp.Body)
if err := resp.Body.Close(); err != nil {
    log.Fatalln(err)
}
fmt.Println(string(body))
</code></pre>
<h3 id="get">get</h3>
<pre><code class="language-go">client := http.Client{}
resp, err := client.Get(&quot;http://www.baidu.com&quot;)
body, err := ioutil.ReadAll(resp.Body)
if err := resp.Body.Close(); err != nil {
    log.Fatalln(err)
}
fmt.Println(string(body))
</code></pre>
<h3 id="post">post</h3>
<pre><code class="language-go">	client := &amp;http.Client{}
	resp, err := client.Post(&quot;http://www.baidu.com&quot;, &quot;text/html&quot;, nil)
	body, err := ioutil.ReadAll(resp.Body)
	if err := resp.Body.Close(); err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(body))
</code></pre>
<h3 id="postform">postForm</h3>
<pre><code class="language-go">client := &amp;http.Client{}
data := url.Values{}
data.Add(&quot;name&quot;, &quot;beijing&quot;)
resp, err := client.PostForm(&quot;http://www.baidu.com&quot;, data)
body, err := ioutil.ReadAll(resp.Body)
if err := resp.Body.Close(); err != nil {
    log.Fatalln(err)
}
fmt.Println(string(body))
</code></pre>
<h3 id="server">server</h3>
<pre><code class="language-go">// ` 代表不转义
const html = `&lt;form method=&quot;POST&quot;&gt;
&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;
&lt;input type=&quot;submit&quot; value=&quot;send&quot;&gt;
&lt;/form&gt;`
//启动http 活动
func server() {
	http.HandleFunc(&quot;/&quot;, GetFormHandler)
	log.Fatal(http.ListenAndServe(&quot;:9000&quot;, nil))
}

//GetFormHandler 函数
func GetFormHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set(&quot;Content-Type&quot;, &quot;text/html&quot;)
	if r.Method == &quot;POST&quot; {
		name := r.FormValue(&quot;name&quot;)
		if name != &quot;&quot; {
			fmt.Fprintln(w, &quot;REcevied&quot;, name)
			return
		}
	}
	fmt.Fprintln(w, html)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[{go} 标准库之 FilePath ]]></title>
        <id>https://bluegrasses.github.io/post/go-filepath/</id>
        <link href="https://bluegrasses.github.io/post/go-filepath/">
        </link>
        <updated>2020-05-25T07:49:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本操作">基本操作</h2>
<h3 id="abs-绝对路径">Abs 绝对路径</h3>
<pre><code class="language-go">absPath := &quot;Z:\\个人区\\golang\\study\\libs\\go.mod&quot;
absPath, err := filepath.Abs(&quot;./go.mod&quot;)
</code></pre>
<h3 id="rel-相对路径">Rel 相对路径</h3>
<pre><code class="language-go">absPath := &quot;Z:\\个人区\\golang\\study\\libs\\go.mod&quot;
relPath, err := filepath.Rel(&quot;Z:\\个人区\\&quot;, absPath)
</code></pre>
<h3 id="dir目录-base文件名-ext后缀">Dir(目录) Base(文件名) Ext(后缀)</h3>
<pre><code class="language-go">dir := filepath.Dir(absPath)
base := filepath.Base(absPath)
ext := filepath.Ext(absPath)
</code></pre>
<h3 id="split-路径分隔">Split 路径分隔</h3>
<p>//如果路径中没有路径分隔符，函数返回值 dir 为空字符串，file 等于 path；<br>
//反之，如果路径中最后一个字符是 /，则 dir 等于 path，file 为空字符串。</p>
<pre><code class="language-go">filepath.Split(&quot;Z:\\个人区\\golang\\study\\libs\\go.mod&quot;)
</code></pre>
<h3 id="clean-路径整理">Clean 路径整理</h3>
<pre><code class="language-go">	uncleanPath := &quot;/Users/Benjamin/./../../Users/Benjamin/Workspace&quot;
	cleaned := filepath.Clean(uncleanPath)
</code></pre>
<h3 id="glob-路径匹配">Glob 路径匹配</h3>
<pre><code class="language-go">pattern := &quot;osdemo/*.go&quot;
filepaths, err := filepath.Glob(pattern)
</code></pre>
<h3 id="hasprefix-文件名是否有前缀">hasPrefix 文件名是否有前缀</h3>
<pre><code class="language-go">result := filepath.HasPrefix(&quot;main.go&quot;, &quot;main&quot;)
</code></pre>
<h3 id="match-路径匹配">match 路径匹配</h3>
<pre><code class="language-go">pattern := &quot;main.*&quot;
name := &quot;main.go&quot;
matched, err := filepath.Match(pattern, name)
</code></pre>
<ul>
<li>toSlash 路径替换为反斜杠</li>
</ul>
<h3 id="walk-遍历目录">walk 遍历目录</h3>
<pre><code class="language-go">	currentDir, err := os.Getwd()
	filepath.Walk(currentDir, walkfn)

func walkfn(path string, fileInfo os.FileInfo, _ error) error {
	fmt.Println(&quot;string:&quot;, path, &quot;info:&quot;, fileInfo.Name())
	return nil
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[{go} 标准库之 os详解]]></title>
        <id>https://bluegrasses.github.io/post/gobiao-zhun-ku-os-xiang-jie/</id>
        <link href="https://bluegrasses.github.io/post/gobiao-zhun-ku-os-xiang-jie/">
        </link>
        <updated>2020-05-24T00:27:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="文件文件夹相关操作">文件(文件夹)相关操作</h2>
<h3 id="文件文件夹常用操作">文件(文件夹)常用操作</h3>
<p>Create 新建文件<br>
Remove 删除<br>
RemoveAll 删除<br>
Mkdir 创建文件夹<br>
Mkdir 创建文件夹可以递归<br>
Rename 改名字<br>
Open 打开<br>
OpenFile 打开文件<br>
<code>OpenFile的使用</code></p>
<pre><code class="language-go">//创建并打开
os.OpenFile(&quot;file.txt&quot;, os.O_CREATE|os.O_RDWR, 0755)
//追加并打开
os.OpenFile(&quot;file.txt&quot;, os.O_APPEND|os.O_RDWR, 0777)
</code></pre>
<p>Stat 返回FileInfo对象</p>
<pre><code>os.Stat(&quot;file&quot;)
</code></pre>
<h3 id="file-文件操作">file 文件操作</h3>
<p>Read 读取文件内容<br>
ReadAt 读取指定偏移的文件内容<br>
ReadDir 好像只能读取一层</p>
<pre><code class="language-go">//返回一个文件类型切片
fi, err := f.Readdir(0)
</code></pre>
<p>Seek 跳转文件指针</p>
<pre><code class="language-go">//第一个参数为偏移量,可以为正负数, 第二个参数为偏移基准. 0位从开始,1表示从当前位置,2表示从末尾
file.Seek(7,1)
</code></pre>
<p>Trucate 文件截取<br>
Sync 内容从内存中提交到硬盘<br>
Write 文件写入<br>
WriteString 文件以字符串形式写入<br>
Stat 返回FileInfo对象</p>
<pre><code class="language-go">file.Stat()
</code></pre>
<h3 id="fileinfo">fileInfo</h3>
<p>Name 文件名<br>
Size 文件大小</p>
<ul>
<li>FileMode struct<br>
<code>fileInfo.Mode().IsDir()</code></li>
</ul>
<h2 id="环境相关">环境相关</h2>
<h3 id="env-检测">env 检测</h3>
<ul>
<li>Environ</li>
</ul>
<pre><code class="language-go">	vars := os.Environ()
	for _, env := range vars {
		fmt.Println(env)
	}
</code></pre>
<pre><code class="language-go">path, err := os.LookupEnv(&quot;PATH&quot;)
</code></pre>
<ul>
<li>Expand</li>
</ul>
<pre><code class="language-go">path1 := os.Expand(&quot;$PATH&quot;, os.Getenv)
</code></pre>
<ul>
<li>Hostname<pre><code class="language-go"></code></pre>
</li>
</ul>
<p>os.Hostname()</p>
<pre><code>设置env
```go
err := os.Setenv(&quot;TMPENV&quot;, &quot;values for testenv&quot;)
</code></pre>
<h3 id="判断">判断</h3>
<ul>
<li>判断错误的IsExist 和isNotExist</li>
</ul>
<pre><code class="language-go">err := os.Mkdir(&quot;tmp&quot;, os.ModePerm)
if os.IsExist(err) {
    ....
}
</code></pre>
<ul>
<li>IsPermission 是否有权限</li>
</ul>
<pre><code class="language-go">file, err := os.OpenFile(&quot;file.txt&quot;, os.O_WRONLY, 0644)
os.IsPermission(err)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[{go} 标准库之 输入输出和文本]]></title>
        <id>https://bluegrasses.github.io/post/go-biao-zhun-ku-shu-ru-shu-chu-he-wen-ben/</id>
        <link href="https://bluegrasses.github.io/post/go-biao-zhun-ku-shu-ru-shu-chu-he-wen-ben/">
        </link>
        <updated>2020-05-21T07:37:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第1章-输入和输出">第1章 输入和输出</h1>
<h2 id="11-io-基本的io接口">1.1 io 基本的io接口</h2>
<h3 id="111-reader-接口">1.1.1 Reader 接口</h3>
<p>Reader 接口的定义如下：</p>
<pre><code class="language-go">type Reader interface {
Read(p []byte) (n int, err error)
}
</code></pre>
<p>Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n<br>
当 Read 在成功读取 n &gt; 0 个字节后遇到一个错误或 EOF (end-of-file)，它会返回读取的字节数</p>
<h3 id="112-write-接口">1.1.2 Write 接口</h3>
<pre><code class="language-go">type Writer interface {
Write(p []byte) (n int, err error)
}
</code></pre>
<p>Write 将 len(p) 个字节从 p 中写入到基本数据流中。它返回从 p 中被写入的字节数 n（0 &lt;= n &lt;= len(p)）以及任何遇到的引起写入提前停止的错误。</p>
<p>os.File 同时实现了 io.Reader 和 io.Writer<br>
strings.Reader 实现了 io.Reader</p>
<h3 id="113-readerat-和-writerat-接口">1.1.3 ReaderAt 和 WriterAt 接口</h3>
<p>ReaderAt 接口的定义如下：</p>
<p>type ReaderAt interface {<br>
ReadAt(p []byte, off int64) (n int, err error)<br>
}</p>
<p>ReadAt 从基本输入源的偏移量 off 处开始，将 len(p) 个字节读取到 p 中。<br>
若 n = len(p) 个字节从输入源的结尾处由 ReadAt 返回，Read可能返回 err == EOF 或者 err == nil</p>
<h3 id="114-readerfrom-和-writerto-接口">1.1.4 ReaderFrom 和 WriterTo 接口</h3>
<p>ReaderFrom 的定义如下：</p>
<p>type ReaderFrom interface {<br>
ReadFrom(r Reader) (n int64, err error)<br>
}</p>
<p>WriterTo的定义如下：</p>
<p>type WriterTo interface {<br>
WriteTo(w Writer) (n int64, err error)<br>
}</p>
<h3 id="115-seeker-接口">1.1.5 Seeker 接口</h3>
<p>接口定义如下：</p>
<p>type Seeker interface {<br>
Seek(offset int64, whence int) (ret int64, err error)<br>
}</p>
<p>Seek 设置下一次 Read 或 Write 的偏移量为 offset，它的解释取决于 whence： 0 表示相对于文件的起始处，1 表示相对于当前的偏移，而 2 表示相对于其结尾处。<br>
whence 的值，在 io 包中定义了相应的常量，应该使用这些常量</p>
<pre><code class="language-go">const (
  SeekStart   = 0 // seek relative to the origin of the file
  SeekCurrent = 1 // seek relative to the current offset
  SeekEnd     = 2 // seek relative to the end
)
</code></pre>
<h3 id="116-close接口">1.1.6 Close接口</h3>
<p>文件 (os.File)、归档（压缩包）、数据库连接、Socket 等需要手动关闭的资源都实现了 Closer 接口。实际编程中，经常将 Close 方法的调用放在 defer 语句中</p>
<h3 id="117-copy-和-copyn-函数">1.1.7 Copy 和 CopyN 函数</h3>
<p>func Copy(dst Writer, src Reader) (written int64, err error)</p>
<p>Copy 将 src 复制到 dst，直到在 src 上到达 EOF 或发生错误。它返回复制的字节数 成功的 Copy 返回 err == nil，而非 err == EOF。</p>
<p>io.Copy(os.Stdout, strings.NewReader(&quot;Go语言中文网&quot;))<br>
输出结果屏幕显示:Go语言中文网</p>
<pre><code class="language-go">func main() {
    //标准输入流 ,直接copy到标准输出流
	io.Copy(os.Stdout, os.Stdin)
	fmt.Println(&quot;退出程序&quot;)
}
</code></pre>
<p>CopyN 函数的签名：<br>
func CopyN(dst Writer, src Reader, n int64) (written int64, err error)</p>
<h3 id="118-writestring-函数">1.1.8 WriteString 函数</h3>
<p>这是为了方便写入 string 类型提供的函数，函数签名：</p>
<p>func WriteString(w Writer, s string) (n int, err error)</p>
<h3 id="119-multireader-和-multiwriter-函数">1.1.9 MultiReader 和 MultiWriter 函数</h3>
<p>这两个函数的定义分别是：<br>
func MultiReader(readers ...Reader) Reader<br>
func MultiWriter(writers ...Writer) Writer<br>
它们接收多个 Reader 或 Writer，返回一个 Reader 或 Writer。我们可以猜想到这两个函数就是操作多个 Reader 或 Writer 就像操作一个。</p>
<h2 id="12-ioutil-方便的io操作函数集">1.2 ioutil — 方便的IO操作函数集</h2>
<h3 id="121-readall-函数">1.2.1 ReadAll 函数</h3>
<p>很多时候，我们需要一次性读取 io.Reader 中的数据</p>
<p>func ReadAll(r io.Reader) ([]byte, error)</p>
<h3 id="122-readdir-函数">1.2.2 ReadDir 函数</h3>
<p>编写程序输出某目录下的所有文件（包括子目录）</p>
<p>fileInfos, err := ioutil.ReadDir(path)</p>
<h3 id="123-readfile-和-writefile-函数">1.2.3 ReadFile 和 WriteFile 函数</h3>
<p>ReadFile 读取整个文件的内容, ReadFile 函数的签名如下:<br>
func ReadFile(filename string) ([]byte, error)<br>
WriteFile 函数的签名如下：<br>
func WriteFile(filename string, data []byte, perm os.FileMode) error</p>
<h2 id="13-bufio-缓存io">1.3 bufio — 缓存IO</h2>
<p>bufio 包提供了两个实例化bufio.Reader对象的函数: NewReader 和 NewReaderSize</p>
<h3 id="131-reader-类型和方法">1.3.1 Reader 类型和方法</h3>
<p>bufio.Reader 结构包装了一个 io.Reader 对象，提供缓存功能，同时实现了 io.Reader 接口</p>
<h3 id="132-writer-类型和方法">1.3.2 Writer 类型和方法</h3>
<p>bufio.Writer 结构包装了一个 io.Writer 对象，提供缓存功能，同时实现了 io.Writer 接口。</p>
<h1 id="第2章-文本">第2章 文本</h1>
<h2 id="21-strings-字符串操作">2.1 strings -- 字符串操作</h2>
<h3 id="211-contians-count">2.1.1 Contians, count</h3>
<pre><code>b := strings.Contains(&quot;hello&quot;, &quot;h&quot;)
count := strings.Count(&quot;hello&quot;, &quot;l&quot;)
</code></pre>
<h3 id="212-字符分割-split-splitn-splitafter">2.1.2 字符分割 Split, SplitN, SplitAfter</h3>
<p>data := strings.SplitN(&quot;中国,日本,韩国&quot;, &quot;,&quot;, 3)<br>
字符串是否有某个前缀或后缀<br>
// s 中是否以 prefix 开始<br>
func HasPrefix(s, prefix string) bool {<br>
return len(s) &gt;= len(prefix) &amp;&amp; s[0:len(prefix)] == prefix<br>
}<br>
// s 中是否以 suffix 结尾<br>
func HasSuffix(s, suffix string) bool {<br>
return len(s) &gt;= len(suffix) &amp;&amp; s[len(s)-len(suffix):] == suffix<br>
}</p>
<h3 id="213-字符串join操作">2.1.3 字符串join操作</h3>
<p>fmt.Println(strings.Join([]string{&quot;name=xxx&quot;, &quot;age=xx&quot;}, &quot;&amp;&quot;))</p>
<h3 id="214-字符串替换-replace">2.1.4 字符串替换 replace</h3>
<p>fmt.Println(strings.ReplaceAll(&quot;我爱php&quot;, &quot;php&quot;, &quot;golang&quot;))<br>
fmt.Println(strings.Replace(&quot;我爱php,我爱golang&quot;, &quot;爱&quot;, &quot;恨&quot;, 1))</p>
<h3 id="215-大小写转换-tolowertoupper">2.1.5 大小写转换 ToLower,ToUpper</h3>
<p>fmt.Println(strings.ToLower(&quot;I Love China&quot;))<br>
fmt.Println(strings.ToUpper(&quot;I love China&quot;))</p>
<h3 id="216-标题处理">2.1.6 标题处理</h3>
<p>Title<br>
func Title(s string) string</p>
<h3 id="217-修剪">2.1.7 修剪</h3>
<p>// 将 s 左侧和右侧中匹配 cutset 中的任一字符的字符去掉<br>
func Trim(s string, cutset string) string<br>
// 将 s 左侧的匹配 cutset 中的任一字符的字符去掉<br>
func TrimLeft(s string, cutset string) string<br>
// 将 s 右侧的匹配 cutset 中的任一字符的字符去掉<br>
func TrimRight(s string, cutset string) string<br>
// 如果 s 的前缀为 prefix 则返回去掉前缀后的 string , 否则 s 没有变化。<br>
func TrimPrefix(s, prefix string) string<br>
// 如果 s 的后缀为 suffix 则返回去掉后缀后的 string , 否则 s 没有变化。<br>
func TrimSuffix(s, suffix string) string<br>
// 将 s 左侧和右侧的间隔符去掉。常见间隔符包括：'\t', '\n', '\v', '\f', '\r', ' ', U+0085 (NEL)<br>
func TrimSpace(s string) string<br>
// 将 s 左侧和右侧的匹配 f 的字符去掉<br>
func TrimFunc(s string, f func(rune) bool) string<br>
// 将 s 左侧的匹配 f 的字符去掉<br>
func TrimLeftFunc(s string, f func(rune) bool) string<br>
// 将 s 右侧的匹配 f 的字符去掉<br>
func TrimRightFunc(s string, f func(rune) bool) string</p>
<h2 id="22-bytes">2.2 bytes</h2>
<p>因为字符串可以表示为 []byte，因此，bytes 包定义的函数、方法等和 strings 包很类似</p>
<h3 id="221-reader类型">2.2.1 reader类型</h3>
<pre><code class="language-go">type Reader struct {
s []byte
i int64 // 当前读取下标
prevRune int // 前一个字符的下标，也可能 &lt; 0
}
</code></pre>
<p>bytes 包下的 Reader 类型实现了 io 包下的 Reader, ReaderAt, RuneReader, RuneScanner, ByteReader, ByteScanner, ReadSeeker, Seeker, WriterTo 等多个接口。主要用于 Read 数据。<br>
我们需要在通过 bytes.NewReader 方法来初始化 bytes.Reader 类型的对象。初始化时传入 []byte 类型的数据。</p>
<p>func NewReader(b []byte) *Reader<br>
例子<br>
x := []byte(&quot;您好,世界&quot;)<br>
r1 := bytes.NewReader(x)<br>
content2 := make([]byte, len(x))<br>
nums, _ := r1.ReadAt(content2, 0)</p>
<h3 id="222-buffer类型">2.2.2 Buffer类型</h3>
<ul>
<li>初始化方法</li>
</ul>
<pre><code class="language-go">a := bytes.NewBufferString(&quot;Hello World&quot;)
b := bytes.NewBuffer([]byte(&quot;Hello World&quot;))
c := bytes.Buffer{}
</code></pre>
<p>例子</p>
<pre><code class="language-go">//新建字节缓存区,定位,r1写入到缓存区
w1 := &amp;bytes.Buffer{}
_, _ = r1.Seek(0, 0)
_, _ = r1.WriteTo(w1)
fmt.Println(w1.String())
</code></pre>
<h2 id="23-strconv-字符串和基本数据类型之间的转换">2.3 strconv 字符串和基本数据类型之间的转换</h2>
<h2 id="24-regexp-正则表达式">2.4 regexp 正则表达式</h2>
<h2 id="25-unicode-编码">2.5 unicode 编码</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[{go} 标准库之  数据、时间、数学函数]]></title>
        <id>https://bluegrasses.github.io/post/go-biao-zhun-ku-shu-ju-shi-jian-shu-xue-han-shu-冲突-漫步的猪_Win10/</id>
        <link href="https://bluegrasses.github.io/post/go-biao-zhun-ku-shu-ju-shi-jian-shu-xue-han-shu-冲突-漫步的猪_Win10/">
        </link>
        <updated>2020-05-17T02:20:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="sort-排序算法">sort 排序算法</h2>
<h3 id="sort方法">sort()方法</h3>
<blockquote>
<p>前面已经提到过,对数据集合(包括定义的数据类型的集合)排序需要实现sort.Interface接口的三个方法,集合实现了这三个方法后,即可调用该2包的sort()方法进行排序.</p>
</blockquote>
<pre><code class="language-go">type Interface interface {
		// 获取数据集合元素个数
		Len() int
		// 如果 i 索引的数据小于 j 索引的数据，返回 true，且不会调用下面的 Swap()，即数据升序排序。
		Less(i, j int) bool
		// 交换 i 和 j 索引的两个元素的位置
        Swap(i, j int)
}
</code></pre>
<p>该包还提供了一个方法可以判断数据集合是否已经排好顺序，该方法的内部实现依赖于我们自己实现的 Len() 和 Less() 方法</p>
<ul>
<li>例子</li>
</ul>
<pre><code class="language-go">// 学生成绩结构体
type StuScore struct {
    name  string    // 姓名
    score int   // 成绩
}

type StuScores []StuScore

//Len()
func (s StuScores) Len() int {
	return len(s)
}

//Less(): 成绩将有低到高排序
func (s StuScores) Less(i, j int) bool {
	return s[i].score &lt; s[j].score
}

//Swap()
func (s StuScores) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

func main() {
    stus := StuScores{
                {&quot;alan&quot;, 95},
                {&quot;hikerell&quot;, 91},
                {&quot;acmfly&quot;, 96},
                {&quot;leao&quot;, 90},
			}		
    //StuScores 已经实现了 sort.Interface 接口 , 所以可以调用 Sort 函数进行排序
	sort.Sort(stus)
	// 判断是否已经排好顺序，将会打印 true
}
</code></pre>
<h3 id="sortissorted-是否排序过">sort.IsSorted()  是否排序过</h3>
<h3 id="reverse-反向排序方法">Reverse() 反向排序方法</h3>
<h3 id="sort包已经支持的内部数据类型排序">sort包已经支持的内部数据类型排序</h3>
<blockquote>
<p>sort包原生支持[]int、[]float64 和[]string 三种内建数据类型切片的排序操作，即不必我们自己实现相关的 Len()、Less() 和 Swap() 方法。</p>
</blockquote>
<h3 id="interface-排序和查找">[]interface 排序和查找</h3>
<h4 id="基本函数">基本函数</h4>
<p>sort 包提供了以下函数：</p>
<p>func Slice(slice interface{}, less func(i, j int) bool)<br>
func SliceStable(slice interface{}, less func(i, j int) bool)<br>
func SliceIsSorted(slice interface{}, less func(i, j int) bool) bool<br>
func Search(n int, f func(int) bool) int</p>
<ul>
<li>slice使用案例</li>
</ul>
<pre><code class="language-go">people := []struct {
	Name string
	Age  int
}{
	{&quot;Gopher&quot;, 7},
	{&quot;Alice&quot;, 55},
	{&quot;Vera&quot;, 24},
	{&quot;Bob&quot;, 75},
}
//排序
//j参数其实相当于i+1=j
sort.Slice(people, func(i, j int) bool { return people[i].Age &lt; people[j].Age }) // 按年龄升序排序
fmt.Println(&quot;Sort by age:&quot;, people)
//判断是否按照某种规则排过序
fmt.Println(&quot;sorted:&quot;, sort.SliceIsSorted(people, func(i, j int) bool {
    return people[i].Age &gt; people[j].Age
}))
</code></pre>
<ul>
<li>sort.Search使用<pre><code class="language-go">	a := []int{2, 3, 4, 200, 100, 21, 234, 56}
  x := 21
  sort.Slice(a, func(i, j int) bool {
  	return a[i] &lt; a[i]
  })
  index := sort.Search(len(a), func(i int) bool { return a[i] &gt;= x })
  fmt.Println(index)
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[{go}  fmt格式化]]></title>
        <id>https://bluegrasses.github.io/post/go-fmt-ge-shi-hua-冲突-漫步的猪_Win10/</id>
        <link href="https://bluegrasses.github.io/post/go-fmt-ge-shi-hua-冲突-漫步的猪_Win10/">
        </link>
        <updated>2020-05-15T23:52:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常用占位符">常用占位符</h2>
<h3 id="普通占位符">普通占位符</h3>
<p>%v 相应值的默认格式。 在打印结构体时，“加号”标记（%+v）会添加字段名<br>
%#v	相应值的Go语法表示<br>
%T 相应值的类型的Go语法表示<br>
%T 相应值的类型的Go语法表示</p>
<h3 id="布尔占位符">布尔占位符</h3>
<p>%t		单词 true 或 false。</p>
<h3 id="整数占位符">整数占位符</h3>
<p>%b		二进制表示<br>
%c		相应Unicode码点所表示的字符	<br>
%d		十进制表示<br>
%o		八进制表示<br>
%q		单引号围绕的字符字面值，由Go语法安全地转义<br>
%x		十六进制表示，字母形式为小写 a-f<br>
%X		十六进制表示，字母形式为大写 A-F<br>
%U		Unicode格式：U+1234，等同于 &quot;U+%04X&quot;</p>
<h3 id="浮点数和复数">浮点数和复数</h3>
<p>%b		无小数部分的，指数为二的幂的科学计数法<br>
%e		科学计数法<br>
%E		科学计数法<br>
%f		有小数点而无指数<br>
%g		根据情况选择<br>
%G		根据情况选择</p>
<h3 id="字符串与字节切片">字符串与字节切片</h3>
<p>%s		输出字符串表示<br>
%q		双引号围绕的字符串<br>
%x		十六进制，小写字母<br>
%X		十六进制，大写字母</p>
<h3 id="指针">指针</h3>
<p>%p		十六进制表示，前缀 0x</p>
<h3 id="其他标记">其他标记</h3>
<ul>
<li>总打印数值的正负号</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[{go} web编程]]></title>
        <id>https://bluegrasses.github.io/post/golang-web-bian-cheng/</id>
        <link href="https://bluegrasses.github.io/post/golang-web-bian-cheng/">
        </link>
        <updated>2020-04-19T11:42:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1表单处理">1.表单处理</h2>
<h3 id="数据获取">数据获取</h3>
<pre><code class="language-go">func root(w http.ResponseWriter, r *http.Request) {
    //1. 使用r.ParseForm()获取数据之后,get post 所有的数据都到了r.Form中
	r.ParseForm()
    //2.使用r.FormValue()从r.Form中检索数据
	fmt.Println(r.FormValue(&quot;name&quot;))

}
func main() {
	http.HandleFunc(&quot;/&quot;, root)
	http.ListenAndServe(&quot;:9000&quot;, nil)
}
</code></pre>
<h3 id="数据验证">数据验证</h3>
<pre><code class="language-go">	r.ParseForm()
	if m, _ := regexp.MatchString(&quot;^[0-9]+$&quot;, r.FormValue(&quot;age&quot;)); !m {
		fmt.Fprintf(w, &quot;age is no valid&quot;)
	}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker 前后端分离项目部署]]></title>
        <id>https://bluegrasses.github.io/post/docker-qian-hou-duan-fen-chi-xiang-mu-bu-shu/</id>
        <link href="https://bluegrasses.github.io/post/docker-qian-hou-duan-fen-chi-xiang-mu-bu-shu/">
        </link>
        <updated>2020-03-31T08:54:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="docker-mysql-集群">docker Mysql 集群</h2>
<h3 id="部署集群环境">部署集群环境</h3>
<blockquote>
<p>基础环境 percona/percona-xtradb-cluster</p>
</blockquote>
<h4 id="1-安装-perconapercona-xtradb-cluster">1. 安装 percona/percona-xtradb-cluster</h4>
<p>···<br>
docker pull percona/percona-xtradb-cluster<br>
···<br>
重命名tag</p>
<pre><code>docker tag percona/percona-xtradb-cluster pxc
</code></pre>
<p>删除多余的images</p>
<pre><code>docker rmi percona/percona-xtradb-cluster
</code></pre>
<h4 id="2-部署专用网络">2. 部署专用网络</h4>
<pre><code>docker network create --subnet=172.18.0.0/25 net1
</code></pre>
<p>查看专用网络信息</p>
<pre><code>docker network inspect net1
</code></pre>
<h4 id="3-创建数据卷volume">3. 创建数据卷volume</h4>
<pre><code>docker volume create v1
</code></pre>
<h4 id="4-创建pxc容器">4. 创建pxc容器</h4>
<p>创建第一个容器<br>
···<br>
docker run -d -p 3306:3306 // 端口映射<br>
-v v1:/var/lib/mysql //映射目录到docker容器<br>
-e MYSQL_ROOT_PASSWORD=abc123456  //设置mysql 参数<br>
-e CLUSTER_NAME=PXC  //集群名称<br>
-e XTRABACKUP_PASSWORD=abc123456 --privileged  //设置数据库节点同步的密码<br>
--name=node1 //节点名称<br>
--net=net1 --ip 172.18.0.2  //设置网络名称<br>
pxc //启动的image名称<br>
···<br>
创建第二个容器，并加入集群<br>
···<br>
docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSSTER_JOIN=node1 -v  v2:/var/lib/mysql --Privileged --name=node2 --net=net2 --ip 172.18.0.3 pxc<br>
···</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kingshard 数据库中间件]]></title>
        <id>https://bluegrasses.github.io/post/kingshard-shu-ju-ku-zhong-jian-jian/</id>
        <link href="https://bluegrasses.github.io/post/kingshard-shu-ju-ku-zhong-jian-jian/">
        </link>
        <updated>2020-03-24T13:46:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基础理论">基础理论</h2>
<p>##kingshard使用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux虚拟机环境搭建]]></title>
        <id>https://bluegrasses.github.io/post/linux-xu-ni-ji-huan-jing-da-jian/</id>
        <link href="https://bluegrasses.github.io/post/linux-xu-ni-ji-huan-jing-da-jian/">
        </link>
        <updated>2020-03-24T10:55:43.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>基本环境 lubuntu 19 虚拟机virtualbox</p>
</blockquote>
<h3 id="首次初始化su密码">首次初始化su密码</h3>
<p>sudo passwd</p>
<h3 id="安装virtualbox-增强工具">安装virtualbox 增强工具</h3>
<ol>
<li>点击安装 增强工具挂载到lubuntn文件中</li>
<li>定位到指定位置,然后 ./VBoxLinuxAdditions.run 运行安装程序</li>
</ol>
<h3 id="虚拟机和主机互通">虚拟机和主机互通</h3>
<ol>
<li>virualbox网络设置为桥接模式</li>
<li>安装ssh软件<br>
检查是否安装了SSH<br>
ps -e|grep ssh<br>
安装ssh服务器端<br>
apt install openssh-server<br>
手工启动<br>
sudo /etc/init.d/ssh start<br>
默认端口为22</li>
</ol>
<h3 id="设置共享目录">设置共享目录</h3>
<ol>
<li>virtualbox 中设置共享文件夹</li>
<li>好像默认挂载到/media/xxx目录下</li>
</ol>
<h3 id="tldr工具安装">tldr工具安装</h3>
<p>sudo apt-get install npm<br>
sudo npm install -g tldr<br>
sudo apt-get install nodejs-legacy</p>
]]></content>
    </entry>
</feed>