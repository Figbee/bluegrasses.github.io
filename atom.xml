<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bluegrasses.github.io</id>
    <title>罗亭的技术博客</title>
    <updated>2020-04-19T11:45:36.418Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bluegrasses.github.io"/>
    <link rel="self" href="https://bluegrasses.github.io/atom.xml"/>
    <subtitle>以梦为马, 诗酒趁年华</subtitle>
    <logo>https://bluegrasses.github.io/images/avatar.png</logo>
    <icon>https://bluegrasses.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 罗亭的技术博客</rights>
    <entry>
        <title type="html"><![CDATA[golang--web编程]]></title>
        <id>https://bluegrasses.github.io/post/golang-web-bian-cheng/</id>
        <link href="https://bluegrasses.github.io/post/golang-web-bian-cheng/">
        </link>
        <updated>2020-04-19T11:42:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="表单处理">表单处理</h2>
<h3 id="数据获取">数据获取</h3>
<pre><code class="language-go">func root(w http.ResponseWriter, r *http.Request) {
    //1. 使用r.ParseForm()获取数据之后,get post 所有的数据都到了r.Form中
	r.ParseForm()
    //2.使用r.FormValue()从r.Form中检索数据
	fmt.Println(r.FormValue(&quot;name&quot;))

}
func main() {
	http.HandleFunc(&quot;/&quot;, root)
	http.ListenAndServe(&quot;:9000&quot;, nil)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker 前后端分离项目部署]]></title>
        <id>https://bluegrasses.github.io/post/docker-qian-hou-duan-fen-chi-xiang-mu-bu-shu/</id>
        <link href="https://bluegrasses.github.io/post/docker-qian-hou-duan-fen-chi-xiang-mu-bu-shu/">
        </link>
        <updated>2020-03-31T08:54:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="docker-mysql-集群">docker Mysql 集群</h2>
<h3 id="部署集群环境">部署集群环境</h3>
<blockquote>
<p>基础环境 percona/percona-xtradb-cluster</p>
</blockquote>
<h4 id="1-安装-perconapercona-xtradb-cluster">1. 安装 percona/percona-xtradb-cluster</h4>
<p>···<br>
docker pull percona/percona-xtradb-cluster<br>
···<br>
重命名tag</p>
<pre><code>docker tag percona/percona-xtradb-cluster pxc
</code></pre>
<p>删除多余的images</p>
<pre><code>docker rmi percona/percona-xtradb-cluster
</code></pre>
<h4 id="2-部署专用网络">2. 部署专用网络</h4>
<pre><code>docker network create --subnet=172.18.0.0/25 net1
</code></pre>
<p>查看专用网络信息</p>
<pre><code>docker network inspect net1
</code></pre>
<h4 id="3-创建数据卷volume">3. 创建数据卷volume</h4>
<pre><code>docker volume create v1
</code></pre>
<h4 id="4-创建pxc容器">4. 创建pxc容器</h4>
<p>创建第一个容器<br>
···<br>
docker run -d -p 3306:3306 // 端口映射<br>
-v v1:/var/lib/mysql //映射目录到docker容器<br>
-e MYSQL_ROOT_PASSWORD=abc123456  //设置mysql 参数<br>
-e CLUSTER_NAME=PXC  //集群名称<br>
-e XTRABACKUP_PASSWORD=abc123456 --privileged  //设置数据库节点同步的密码<br>
--name=node1 //节点名称<br>
--net=net1 --ip 172.18.0.2  //设置网络名称<br>
pxc //启动的image名称<br>
···<br>
创建第二个容器，并加入集群<br>
···<br>
docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSSTER_JOIN=node1 -v  v2:/var/lib/mysql --Privileged --name=node2 --net=net2 --ip 172.18.0.3 pxc<br>
···</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kingshard 数据库中间件]]></title>
        <id>https://bluegrasses.github.io/post/kingshard-shu-ju-ku-zhong-jian-jian/</id>
        <link href="https://bluegrasses.github.io/post/kingshard-shu-ju-ku-zhong-jian-jian/">
        </link>
        <updated>2020-03-24T13:46:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基础理论">基础理论</h2>
<p>##kingshard使用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux虚拟机环境搭建]]></title>
        <id>https://bluegrasses.github.io/post/linux-xu-ni-ji-huan-jing-da-jian/</id>
        <link href="https://bluegrasses.github.io/post/linux-xu-ni-ji-huan-jing-da-jian/">
        </link>
        <updated>2020-03-24T10:55:43.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>基本环境 lubuntu 19 虚拟机virtualbox</p>
</blockquote>
<h3 id="首次初始化su密码">首次初始化su密码</h3>
<p>sudo passwd</p>
<h3 id="安装virtualbox-增强工具">安装virtualbox 增强工具</h3>
<ol>
<li>点击安装 增强工具挂载到lubuntn文件中</li>
<li>定位到指定位置,然后 ./VBoxLinuxAdditions.run 运行安装程序</li>
</ol>
<h3 id="虚拟机和主机互通">虚拟机和主机互通</h3>
<ol>
<li>virualbox网络设置为桥接模式</li>
<li>安装ssh软件<br>
检查是否安装了SSH<br>
ps -e|grep ssh<br>
安装ssh服务器端<br>
apt install openssh-server<br>
手工启动<br>
sudo /etc/init.d/ssh start<br>
默认端口为22</li>
</ol>
<h3 id="设置共享目录">设置共享目录</h3>
<ol>
<li>virtualbox 中设置共享文件夹</li>
<li>好像默认挂载到/media/xxx目录下</li>
</ol>
<h3 id="tldr工具安装">tldr工具安装</h3>
<p>sudo apt-get install npm<br>
sudo npm install -g tldr<br>
sudo apt-get install nodejs-legacy</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go 语言杂项]]></title>
        <id>https://bluegrasses.github.io/post/go-yu-yan-za-xiang/</id>
        <link href="https://bluegrasses.github.io/post/go-yu-yan-za-xiang/">
        </link>
        <updated>2020-03-19T15:03:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="defer-panic-recover">defer panic recover</h2>
<pre><code class="language-go">func main() {
	defer func() {
		err := recover()
		fmt.Println(&quot;异常信息是:&quot;, err)
	}()
	panic(&quot;it is panic&quot;)
}
</code></pre>
<h2 id="go键盘输入">go键盘输入</h2>
<p>Scanln和Scanf类似于println和printf</p>
<pre><code class="language-go">func main() {
	var x int
	var y float64
	fmt.Println(&quot;请输入一个整数，一个浮点类型：&quot;)
	fmt.Scanln(&amp;x, &amp;y) //读取键盘的输入，通过操作地址，赋值给x和y   阻塞式
	fmt.Printf(&quot;x的数值：%d，y的数值：%f\n&quot;, x, y)

	fmt.Scanf(&quot;%d,%f&quot;, &amp;x, &amp;y)
	fmt.Printf(&quot;x:%d,y:%f\n&quot;, x, y)
}
</code></pre>
<h2 id="缓冲区的输入">缓冲区的输入</h2>
<pre><code class="language-go">func main() {
	fmt.Println(&quot;请输入一个字符串:&quot;)
	//创建一个缓冲区,缓冲区读取的内容是标准输入流
	reader := bufio.NewReader(os.Stdin)
	//读取缓冲区,知道遇到\n操作
	s1, _ := reader.ReadString('\n')
	fmt.Println(&quot;读到的数据:&quot;, s1)
}
</code></pre>
<h2 id="打印数据类型">打印数据类型</h2>
<pre><code class="language-go">	var a = [...]int{0: 1, 3: 3}
	//使用反射打印数据类型
	fmt.Println(reflect.TypeOf(a))
	//使用Printf打印数据类型
	fmt.Printf(&quot;%T&quot;, a)
</code></pre>
<h2 id="函数的使用">函数的使用</h2>
<h3 id="函数可变参数">函数可变参数</h3>
<pre><code class="language-go">func getAdd(nums ...int) {
	sum := 0
	for i := 0; i &lt; len(nums); i++ {
		sum += nums[i]
	}
	fmt.Println(sum)
}
</code></pre>
<h2 id="结构体的使用">结构体的使用</h2>
<h3 id="method-继承">method 继承</h3>
<pre><code class="language-go">type Human struct{
	name string
	age int
	phone string
}
type Student struct{
	Human
	school string
}
type Commpany struct{
	Human
	Commpany string
}
func (h* Human) SayHi(){
	fmt.Printf(&quot;i am %s you can call me on %s\n&quot;,h.name,h.phone)
}
func main(){
	mark:=Student{Human{&quot;yxg&quot;,40,&quot;15548551999&quot;},&quot;btsy&quot;}
	tom:=Commpany{Human{&quot;tom&quot;,20,&quot;13348551950&quot;},&quot;bjyddx&quot;}
	mark.SayHi()
	tom.SayHi()
}
</code></pre>
<h2 id="断言">断言</h2>
<h3 id="断言方式1">断言方式1</h3>
<blockquote>
<p>安全类型断言<br>
&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 )</p>
</blockquote>
<pre><code class="language-go">type Student struct {
	name string
	age  int
	city string
}
func main(){
    var i1 interface{}
	i1 = Student{}
    data,ok:=i1.(Student)
    if ok{

    }
}
</code></pre>
<h3 id="断言方式2">断言方式2</h3>
<blockquote>
<p>s.(type)</p>
</blockquote>
<pre><code class="language-go">func main(){
    var i1 interface{}
	i1 = Student{}
    switch t := i1.(type) {
	case Student:
		fmt.Println(&quot;student 类型&quot;, t)
	default:
		fmt.Println(&quot;未知类型&quot;)
	}
}
</code></pre>
<h2 id="文件操作">文件操作</h2>
<h3 id="基本操作语法">基本操作语法</h3>
<blockquote>
<p>file 操作 封装在os 包</p>
</blockquote>
<ol>
<li>创建文件夹，如果文件夹存在，创建失败<br>
os.MkDir() 创建文件夹<br>
os.MKDirAll() 可以创建多层</li>
<li>创建文件<br>
os.Create() 创建文件 采用模式0666任何人都可读写,不可执行</li>
<li>打开文件<br>
os.Open(filename)<br>
os.OpenFile(filename,mode,perm)</li>
<li>关闭文件:<br>
file.Close()</li>
<li>删除文件或目录<br>
os.Remove() //删除文件和空目录<br>
os.RemoveAll()//删除所有</li>
</ol>
]]></content>
    </entry>
</feed>