<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bluegrasses.github.io</id>
    <title>罗亭的技术博客</title>
    <updated>2020-11-02T03:09:54.668Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bluegrasses.github.io"/>
    <link rel="self" href="https://bluegrasses.github.io/atom.xml"/>
    <subtitle>人生不是一个结果, 是一段路, 连接此岸和彼岸</subtitle>
    <logo>https://bluegrasses.github.io/images/avatar.png</logo>
    <icon>https://bluegrasses.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 罗亭的技术博客</rights>
    <entry>
        <title type="html"><![CDATA[larachina03学习笔记]]></title>
        <id>https://bluegrasses.github.io/post/larachina03-xue-xi-bi-ji/</id>
        <link href="https://bluegrasses.github.io/post/larachina03-xue-xi-bi-ji/">
        </link>
        <updated>2020-11-01T23:10:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="杂项问题">杂项问题</h2>
<h3 id="postman-启动空白修复">postman 启动空白修复</h3>
<blockquote>
<p>解决方法:</p>
<p>环境变量-&gt;添加系统变量(添加POSTMAN_DISABLE_GPU = true)</p>
</blockquote>
<h3 id="cerbot-部署https">cerbot 部署https</h3>
<blockquote>
<p>利用宝塔更方便点</p>
</blockquote>
<h3 id="宝塔远程连接数据库">宝塔远程连接数据库</h3>
<p>1.数据库权限设为所有人或指定ip</p>
<p>2.宝塔安全中放行3306端口</p>
<h2 id="restful设计原则">RESTful设计原则</h2>
<h3 id="常用动词">常用动词</h3>
<ul>
<li>
<p>GET：读取（Read）</p>
</li>
<li>
<p>POST：新建（Create）</p>
</li>
<li>
<p>PUT：更新（Update）</p>
</li>
<li>
<p>PATCH：更新（Update），通常是部分更新</p>
</li>
<li>
<p>DELETE：删除（Delete）</p>
</li>
</ul>
<blockquote>
<p>根据 HTTP 规范，动词一律大写</p>
</blockquote>
<h3 id="版本控制">版本控制</h3>
<p><strong>两种情况:</strong></p>
<p>第一种情况</p>
<p><code>https://api.larabbs.com/v1</code></p>
<p><code>https://api.larabbs.com/v2</code></p>
<p>第二种情况</p>
<p><code>https://api.larabbs.com/ Accept: application/prs.larabbs.v1+json</code></p>
<p><code>https://api.larabbs.com/ Accept: application/prs.larabbs.v1+json</code></p>
<h3 id="路由命名">路由命名</h3>
<p>两个关键词: 复数 命名不要有动词</p>
<p><code>POST https://api.larabbs.com/topic</code></p>
<p><code>GET https://api.larabbs.com/topics/1</code></p>
<p><code>POST https://api.larabbs.com/topics/1/comments</code></p>
<p><code>DELETE https://api.larabbs.com/topics/1/comments/10</code></p>
<h3 id="资源过滤">资源过滤</h3>
<pre><code>?state=closed: 不同状态的资源
?page=2&amp;per_page=100：访问第几页数据，每页多少条。
?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序
</code></pre>
<h3 id="状态码">状态码</h3>
<p>HTTP状态码就是一个三位数, 分成五个类别</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx</td>
<td>相关信息</td>
</tr>
<tr>
<td>2xx</td>
<td>操作成功</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误</td>
</tr>
<tr>
<td>5xx</td>
<td>服务器错误</td>
</tr>
</tbody>
</table>
<blockquote>
<p>200 表示操作成功,但是不同的方法可以返回更精确的状态码</p>
</blockquote>
<pre><code class="language-php">GET: 200 OK
POST: 201 Created
PUT: 200 OK
PATCH: 200 OK
DELETE: 204 No Content
</code></pre>
<pre><code>//2xx
200 OK - 对成功的 GET、PUT、PATCH 或 DELETE 操作进行
响应。也可以被用在不创建新资源的 POST 操作上
201 Created - 对创建新资源的 POST 操作进行响应。应该带
着指向新资源地址的 Location 头
202 Accepted - 服务器接受了请求，但是还未处理，响应中应
该包含相应的指示信息，告诉客户端该去哪里查询关于本次请
求的信息
204 No Content - 对不会返回响应体的成功请求进行响应（比
如 DELETE 请求）
//3xx
304 Not Modified - HTTP缓存header生效的时候用
// 4xx
400 Bad Request - 请求异常，比如请求中的body无法解析
401 Unauthorized - 没有进行认证或者认证非法
403 Forbidden - 服务器已经理解请求，但是拒绝执行它
404 Not Found - 请求一个不存在的资源
405 Method Not Allowed - 所请求的 HTTP 方法不允许当前认证用户访问
410 Gone - 表示当前请求的资源不再可用。当调用老版本 API的时候很有用
415 Unsupported Media Type - 如果请求中的内容类型是错误的
422 Unprocessable Entity - 用来表示校验错误
429 Too Many Requests - 由于请求频次达到上限而被拒绝访问
//5xx
5xx 状态码表示服务端错误. 一般来说,API不会向用户透露服务器的详细信息,所以只要两个状态码就够了
500 Internal Server Error：客户端请求有效，服务器处理时发生了意外。
503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态。
</code></pre>
<h3 id="数据响应格式">数据响应格式</h3>
<h3 id="调用频率限制">调用频率限制</h3>
<p>为了防止服务器被攻击，减少服务器压力，需要对接口进行合适的限流控制，需要在响应头信息中加入合适的信息，告知客户端当前的限流情况</p>
<pre><code>X-RateLimit-Limit :100 最大访问次数
X-RateLimit-Remaining :93 剩余的访问次数
X-RateLimit-Reset :1513784506 到该时间点，访问次数会重置
为 X-RateLimit-Limit
</code></pre>
<h3 id="接口关联">接口关联</h3>
<blockquote>
<p>做接口的思路与我们做网页应用不同，网站中处理验证码，通常是存入 session，注册的时候验证用户输入的验证码与 session 中的验证码是否相同。但是接口是无状态，相互独立的，处理这种相互关联，有先后调用顺序的接口时，常常是第一个接口返回一个随机的 key，利用这个 key 去调用第二个接口。</p>
</blockquote>
<h2 id="dingoapi">dingo/api</h2>
<p>组件名:<code>dingo/api</code></p>
<h3 id="常用配置">常用配置</h3>
<pre><code class="language-php">#有三个配置项  x 本地开发的或私有环境 prs 提供给公司app,单页面等 vnd 对外发布的,开放给所有用户
API_STANDARDS_TREE=prs
#项目简称
APISUBTYPE=larabbs
#项目前缀或子域名, www.larabbs.com/api
API_PREFIX=api
#api.larabbs.com
API_DOMAIN=api.larabbs.com   
API_DEBUG=true
API_VERSION=v1
#严格模式
APISTRICT=false
</code></pre>
<h4 id="访问不同版本的接口方法">访问不同版本的接口方法</h4>
<p>访问 v1 版本<br>
Accept: application/prs.larabbs.v1+json<br>
访问 v2 版本<br>
Accept: application/prs.larabbs.v2+json</p>
<h3 id="api认证">API认证</h3>
<h3 id="include机制">include机制</h3>
<blockquote>
<p>场景: 获取帖子的作者和栏目信息</p>
</blockquote>
<h4 id="步骤">步骤</h4>
<ol>
<li>在transformer中定义方法</li>
</ol>
<pre><code class="language-php">       //
       protected $availableIncludes=['user','category'];
       //Topic模型中必须有user()方法
       public function includeUser(Topic $topic){
           return $this-&gt;item($topic-&gt;user,new UserTransformer());
       }
</code></pre>
<h4 id="定义">定义</h4>
<pre><code class="language-php">class TopicTransformer extends TransformerAbstract
{
    protected $availableIncludes=['user','category'];

    public function transform(Topic $topic)
    {
		.......
    }

    public function includeUser(Topic $topic){
        return $this-&gt;item($topic-&gt;user,new UserTransformer());
    }

    public function includeCategory(Topic $topic){
        return $this-&gt;item($topic-&gt;category,new CategoryTransformer());
    }
}
</code></pre>
<h4 id="使用">使用:</h4>
<figure data-type="image" tabindex="1"><img src="assets%5C1562034971827.png" alt="1562034971827" loading="lazy"></figure>
<p>调用多个include 将参数写成: xxx.com/api/topics?include=user,category</p>
<p>遇到复杂的嵌套关系可以手动关闭dingo的预加载</p>
<p>app(\Dingo\Api\Transformer\Factory::class)-&gt;disableEagerLoading();</p>
<h4 id="include嵌套">include嵌套</h4>
<p><code>user.roles</code></p>
<figure data-type="image" tabindex="2"><img src="assets%5C1562141101676.png" alt="1562141101676" loading="lazy"></figure>
<h2 id="短信发送">短信发送</h2>
<p>组件 : <code>overtrue/easy-sms</code></p>
<h3 id="easy-sms-组件封装">easy-sms 组件封装</h3>
<h4 id="1创建config文件">1.创建config文件</h4>
<p>config/easysms.php</p>
<pre><code class="language-php">return [
    // HTTP 请求的超时时间（秒）
    'timeout' =&gt; 5.0,
    // 默认发送配置
    'default' =&gt; [
        // 网关调用策略，默认：顺序调用
        'strategy' =&gt; \Overtrue\EasySms\Strategies\OrderStrategy::class,
        // 默认可用的发送网关
        'gateways' =&gt; [
            'yunpian'
        ],
    ],
    // 可用的网关配置
    'gateways' =&gt; [
        'errorlog' =&gt; [
            'file' =&gt; '/tmp/easy-sms.log',
        ],
        'yunpian' =&gt; [
            'api_key' =&gt; '04d7a301137c06e0dde555b0216e7cfe',
        ],
    ],
];
</code></pre>
<h4 id="2添加服务提供者">2.添加服务提供者</h4>
<p>app/providers/EasySmsServiceProvider.php</p>
<pre><code class="language-php">public function boot()
{
    $this-&gt;app-&gt;singleton(EasySms::class,function($app){
        return new EasySms(config('easysms'));
    });
    //设置别名
    $this-&gt;app-&gt;alias(EasySms::class,'easysms');
}
</code></pre>
<blockquote>
<p>在 config/app.php 的provides函数中注册服务提供者</p>
</blockquote>
<h4 id="3发送简单代码">3.发送简单代码</h4>
<pre><code class="language-php">$sms = app('easysms');
try{
$sms-&gt;send(15548551950, [
//这里必须和短信模板严格匹配
'content'  =&gt; '【杨晓光】你的验证码是12343。如非本人操作请忽略',
]);
}catch (\Overtrue\EasySms\Exceptions\NoGatewayAvailableException $e){
$message=$e-&gt;getException('yunpian')-&gt;getMessage();
dd($message);
}
</code></pre>
<h3 id="短信发送涉及知识点">短信发送涉及知识点</h3>
<blockquote>
<p>str_pad()</p>
<p>random_int()</p>
<p>hash_equals() 字符串比较,防止时序攻击</p>
</blockquote>
<h2 id="接口验证码">接口验证码</h2>
<p>插件名称: <code>gregwar/captcha</code></p>
<h3 id="简单实用案例">简单实用案例</h3>
<pre><code class="language-php">//生成验证码
$builder=new CaptchaBuilder();
$captcha=$builder-&gt;build();
//生成图片显示地址
$captch-&gt;inline();
//获取图片验证码的值
$captch-&gt;getPhrase();
</code></pre>
<h2 id="oauth登录">OAUTH登录</h2>
<h3 id="oauth20基础">OAUTH2.0基础</h3>
<h4 id="授权模式">授权模式</h4>
<p>参考文章:<a href="https://learnku.com/articles/20082">oaut图解</a></p>
<ol>
<li>授权码模式</li>
<li>简化模式</li>
<li>密码模式</li>
<li>客户端模式</li>
</ol>
<h3 id="socialite-providers">Socialite Providers</h3>
<p>插件: <a href="https://socialiteproviders.netlify.com/">Socialite Providers     </a></p>
<p>插件扩展: https://socialiteproviders.netlify.com/about.html</p>
<h4 id="登录的两种方式">登录的两种方式</h4>
<ol>
<li><strong>客户端保存accessToken</strong></li>
</ol>
<pre><code class="language-php">$accessToken = 'ACCESS_TOKEN';
$openID = 'OPEN_ID';
$driver = Socialite::driver('weixin');
$driver-&gt;setOpenId($openID);
$oauthUser = $driver-&gt;userFromToken($accessToken);
</code></pre>
<ol start="2">
<li><strong>客户端只获取授权码(code)</strong></li>
</ol>
<blockquote>
<p>这种方式是推荐的安全做法, 客户端不保存app_secrect ,获取到code之后交给服务器换取access_token以及取用用户信息.</p>
</blockquote>
<p>config/services.php</p>
<pre><code class="language-php">'weixin' =&gt; [
    'client_id' =&gt; env('WEIXIN_KEY'),
    'client_secret' =&gt; env('WEIXIN_SECRET'),
    'redirect' =&gt; env('WENXIN_REBACK_URL'),
]
</code></pre>
<pre><code class="language-php">$code = 'CODE';
$driver = Socialite::driver('weixin');
$response = $driver-&gt;getAccessTokenResponse($code);
//微信需要传递openid
$driver-&gt;setOpenId($response['openid']);
$oauthUser = $driver-&gt;userFromToken($response['access_token']);
</code></pre>
<h4 id="oauth注册的两种情况">oauth注册的两种情况</h4>
<ol>
<li>
<p>用户第一次使用微信登录，根据微信的数据，在 项目中创 建一个用户，返回该用户的登录凭证</p>
</li>
<li>
<p>用户已经使用过微信登录，则找到数据库中对应的用户，返回 该用户的登录凭证</p>
</li>
</ol>
<pre><code class="language-php">   路由: $api-&gt;post('socials/{social_type}/authorizations', &quot;AuthorizationsController@weiXinLogin&quot;)-&gt;name('api.socials.authorizations.store');
   public function weiXinLogin($type, AuthorizationsRequest $request)
   {
       if (!in_array($type, ['weixin'])) {
           return $this-&gt;response-&gt;errorBadRequest();
       }
       $driver = \Socialite::driver($type);
       try {
           /*如果传递是code*/
           if ($code = $request-&gt;code) {
               $response = $driver-&gt;getAccessTokenResponse($code);
               $token = array_get($response, 'access_token');
           } else {
               $token = $request-&gt;access_token;
               if ($type == 'weixin') {
                   $driver-&gt;setOpenId($request-&gt;openid);
               }
           }
           $oauthUser = $driver-&gt;userFromToken($token);
       } catch (\Exception $e) {
           return $this-&gt;response-&gt;errorUnauthorized('参数错误');
       }
       /*根据获取的用户信息,去数据库中查找,如果存在则将查询结果返回,否则新建数据并返回*/
       switch ($type) {
           case 'weixin':
               $unionid = $oauthUser-&gt;offsetExists('unionid') ? $oauthUser-&gt;offsetGet('unionid') : null;
               if ($unionid) {
                   /*如果有unionid则用unionid查询,否则用openid查询*/
                   $user = User::where('weixin_unionid', $unionid)-&gt;first();
               } else {
                   $user = User::where('weixin_openid', $oauthUser-&gt;getId())-&gt;first();
               }
               if (!$user) {
                   $user = User::create([
                       'name' =&gt; $oauthUser-&gt;getNickname(),
                       'avatar' =&gt; $oauthUser-&gt;getAvatar(),
                       'wenxin_opeinid' =&gt; $oauthUser-&gt;getId(),
                       'weixin_unionid' =&gt; $unionid,
                   ]);
               }
               break;
       }
       //这里临时先返回id值
       $token = \Auth::guard('api')-&gt;fromUser($user);
       return $this-&gt;authResult($token)-&gt;setStatusCode(200);
   }
</code></pre>
<h4 id="微信的openid和unionid">微信的openid和unionid</h4>
<p>那么如何来分辨用户是否已存在，就需要一个用户的唯一标识。任何 一个第三方平台，返回的用户信息都会有一个唯一标 识， socialite  已经为我们封装好了，直接使用  $oauthUser&gt;getId()  即可获取，对于微信来说，这个唯一标识叫做 openid .</p>
<p>如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程 序），可通过 unionid 来区分用户的唯一性，因为只要是同一个微 信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程 序），用户的 unionid 是唯一的。换句话说，同一用户，对同一个 微信开放平台下的不同应用，unionid 是相同的。</p>
<h3 id="采坑记录">采坑记录</h3>
<h4 id="获取用户信息错误">获取用户信息错误</h4>
<p>错误提示:</p>
<p><code>GuzzleHttp/Exception/RequestException with message 'cURL error 60: SSL certificate problem: unable to get local issuer certificate (see http://curl.haxx.se/libcurl/c/libcurl-errors.html)'</code></p>
<p>问题解决:</p>
<p>估计和本地的ssl证书有关系,远程的暂未测试</p>
<pre><code class="language-php">1. Download the latest cacert.pem from https://curl.haxx.se/ca/cacert.pem
2. Add the following line to php.ini:
curl.cainfo=&quot;/path/to/downloaded/cacert.pem&quot;
</code></pre>
<h2 id="jwt">JWT</h2>
<h3 id="项目入门">项目入门</h3>
<p><code>tymondesigns/jwt-auth</code></p>
<p>项目文档: <a href="https://jwt-auth.readthedocs.io/en/develop/">https://jwt-auth.readthedocs.io/en/develop/</a></p>
<h3 id="部署和配置">部署和配置</h3>
<p>配置项jwt.php</p>
<pre><code class="language-php">//生成的密匙
'secret' =&gt; env('JWT_SECRET'),
//token过期时间
'ttl' =&gt; env('JWT_TTL', 60),
//刷新过期时间,刷新过期时间一般比token时间长,在刷新过期时间,即使token过期,任然可以获取一个新的token,不需要重新登录                                         
 'refresh_ttl' =&gt; env('JWT_REFRESH_TTL', 20160),
</code></pre>
<p>配置config/auth.php</p>
<pre><code class="language-php">guards' =&gt; [ 
    'api' =&gt; [ 
        'driver' =&gt; 'jwt', 
        'provider' =&gt; 'users', 
    ], 
],
</code></pre>
<p>配置config/api.php</p>
<pre><code class="language-php">'auth' =&gt; [ 
    'jwt' =&gt; 'Dingo\Api\Auth\Provider\JWT', 
], 
</code></pre>
<p>配置user模型</p>
<pre><code class="language-php">class User extends Authenticatable implements JWTSubject 
 
    public function getJWTIdentifier() 
    { 
        return $this-&gt;getKey(); 
    } 
 
    public function getJWTCustomClaims() 
    { 
        return [];
    }
</code></pre>
<h3 id="常用方法">常用方法</h3>
<h4 id="token生成">token生成</h4>
<pre><code class="language-php">//基于账号密码生成token
$credentials=request(['email','password']);
auth('api')-&gt;attempt($credentials);
//基于用户模型生成token
$user=User::first();
auth('api')-&gt;fromUser($user);
//基于users模型中的主键id
auth('api')-&gt;tokenById(1);
</code></pre>
<h4 id="token解析">token解析</h4>
<pre><code class="language-php">//把请求发送过来的直接解析到对象
JWTAuth::parseToken();
//获取token中的user信息
auth('api')-&gt;user();
//获取token,如果token被设置则返回,否则返回false
auth('api')-&gt;getToken();
</code></pre>
<h4 id="token控制">token控制</h4>
<pre><code class="language-php">//更新token
$token=auth('api')-&gt;refresh();
//让一个token无效
auth('api')-&gt;invalidate();
//检验token的有效性
auth('api')-&gt;check();

</code></pre>
<h4 id="token其他方法">token其他方法</h4>
<pre><code class="language-php">//设置荷载
$token=auth('api')-&gt;claims(['foo'=&gt;'bar'])-&gt;attempt($credentials);
//重写有效时间
auth('api')-&gt;setTTL(7200)-&gt;attempt($credentials);
//验证账号是否正确
auth('api')-&gt;validate($credentials);
</code></pre>
<h3 id="使用案例">使用案例</h3>
<ol>
<li>composer 安装</li>
</ol>
<pre><code class="language-php">composer require tymon/jwt-auth 1.*@rc
</code></pre>
<blockquote>
<p>通过该命令安装的可能为0.5.*版本,执行composer update命令进行升级版本或者直接指定版本号</p>
</blockquote>
<ol start="2">
<li>生成密匙</li>
</ol>
<p><code>php artisan jwt:secret</code></p>
<ol start="3">
<li>修改config/auth.php</li>
</ol>
<pre><code class="language-php">'guards' =&gt; [
    'api' =&gt; [
        'driver' =&gt; 'jwt',
        'provider' =&gt; 'users',
    ],
]
</code></pre>
<ol start="4">
<li>修改 config/api.php</li>
</ol>
<pre><code class="language-php">'auth' =&gt; [
    'jwt'=&gt;'Dingo\Api\Auth\Provider\JWT',
],
</code></pre>
<ol start="5">
<li>修改user.php模型</li>
</ol>
<p>让user.php 实现use Tymon\JWTAuth\Contracts\JWTSubject;</p>
<pre><code class="language-php">class User extends Authenticatable implements JWTSubject
{
        //这里返回了User的id
    public function getJWTIdentifier()
    {
        return $this-&gt;getKey();
    }

    //这里是我们需要额外在jwt中增加的自定义内容
    public function getJWTCustomClaims()
    {
        return [];
    }
}
</code></pre>
<ol start="6">
<li>注册provide和alias</li>
</ol>
<blockquote>
<p>config/app.php</p>
</blockquote>
<pre><code>   'aliases'=&gt;[
       'JWTAuth'=&gt;'Tymon\JWTAuth\Facades\JWTAuth',
       'JWTFactory'=&gt;'Tymon\JWTAuth\Facades\JWTFactory'
   ]
</code></pre>
<blockquote>
<p>如果你不适用这两个Facade,你可以使用辅助函数auth()</p>
</blockquote>
<p>auth辅助函数与jwt扩展</p>
<ol start="7">
<li>jwt的几种常用操作<br>
路由</li>
</ol>
<pre><code>   //登录
   Route::post('login','AuthController@login');
   //注销token
   Route::delete('logout','AuthController@logout');
   //刷新token
   Route::put('refresh','AuthController@refresh');
   //获取信息
   Route::post('me','AuthController@me');
</code></pre>
<p>控制器</p>
<pre><code class="language-php">   public function store(AuthRequest $request)
   {
       //传入两个参数username,password.这里username 可能有是邮箱或者电话,需要判断一下
       $username = $request-&gt;username;
       filter_var($username, FILTER_VALIDATE_EMAIL) ? $credentials['email'] = $username : $credentials['phone'] = $username;
       $credentials['password'] = $request-&gt;password;
       $token = \Auth::guard('api')-&gt;attempt($credentials);
       if (!$token) {
           return $this-&gt;response-&gt;errorUnauthorized('用户名密码不正确');
       }
       //这里定义一个通用的返回信息函数
       return $this-&gt;authResult($token)-&gt;setStatusCode(200);
   }
   
   /**微信oauth 登录
        * @param $type 路由中的第三方登录类型参数,如weixin
        * @param AuthorizationsRequest $request
        */
   public function weiXinLogin($type, AuthorizationsRequest $request)
   {
       if (!in_array($type, ['weixin'])) {
           return $this-&gt;response-&gt;errorBadRequest();
       }
       $driver = \Socialite::driver($type);
       try {
           /*如果传递是code*/
           if ($code = $request-&gt;code) {
               $response = $driver-&gt;getAccessTokenResponse($code);
               $token = array_get($response, 'access_token');
           } else {
               $token = $request-&gt;access_token;
               if ($type == 'weixin') {
                   $driver-&gt;setOpenId($request-&gt;openid);
               }
           }
           $oauthUser = $driver-&gt;userFromToken($token);
       } catch (\Exception $e) {
           return $this-&gt;response-&gt;errorUnauthorized('参数错误');
       }
       /*根据获取的用户信息,去数据库中查找,如果存在则将查询结果返回,否则新建数据并返回*/
       switch ($type) {
           case 'weixin':
               $unionid = $oauthUser-&gt;offsetExists('unionid') ? $oauthUser-&gt;offsetGet('unionid') : null;
               if ($unionid) {
                   /*如果有unionid则用unionid查询,否则用openid查询*/
                   $user = User::where('weixin_unionid', $unionid)-&gt;first();
               } else {
                   $user = User::where('weixin_openid', $oauthUser-&gt;getId())-&gt;first();
               }
               if (!$user) {
                   $user = User::create([
                       'name' =&gt; $oauthUser-&gt;getNickname(),
                       'avatar' =&gt; $oauthUser-&gt;getAvatar(),
                       'wenxin_opeinid' =&gt; $oauthUser-&gt;getId(),
                       'weixin_unionid' =&gt; $unionid,
                   ]);
               }
               break;
       }
       //这里临时先返回id值
       $token = \Auth::guard('api')-&gt;fromUser($user);
       return $this-&gt;authResult($token)-&gt;setStatusCode(200);
   }
   
   public function refresh()
   {
       $token=\Auth::guard('api')-&gt;refresh();
       return $this-&gt;authResult($token)-&gt;setStatusCode(200);
   }
   
   public function destroy()
   {
       \Auth::guard('api')-&gt;logout();
       //noContent 返回的状态码 204
       return $this-&gt;response-&gt;noContent();
   }
   
   protected function authResult($token)
   {
       return $this-&gt;response-&gt;array([
           'access_token' =&gt; $token,
           'token_type' =&gt; 'Bearer',
           'expires_in' =&gt; \Auth::guard('api')-&gt;factory()-&gt;getTTL() * 60
       ]);
   }
</code></pre>
<blockquote>
<p>refresh() token 刷新 destroy 销毁 都需要携带 Authorization:Bear  {token}</p>
</blockquote>
<h2 id="transformers">Transformers</h2>
<blockquote>
<p>通过转化器, 你可以将对象转化为数组, 并强制转化整型和布尔类型, 包括分页结果和嵌套关联.</p>
</blockquote>
<h3 id="fractal">Fractal</h3>
<p>Dingo API 底层使用 <a href="https://github.com/thephpleague/fractal">Fractal</a> 作为默认的转化层</p>
<p>Fractal 的意义在原始数据和输出数据中间搞一个墙('barrier'), 这样的话即使内部结构改变了也不会影响到用户</p>
<h4 id="资源分类">资源分类:</h4>
<ul>
<li><code>League\Fractal\Resource\Item</code>：单个资源</li>
<li><code>League\Fractal\Resource\Collection</code>：资源集合</li>
</ul>
<h4 id="简单案例">简单案例</h4>
<pre><code class="language-php">Route::get('/fractal/resource/collection', function () {
    $tasks = \App\Task::all();
    $resource = new \League\Fractal\Resource\Collection($tasks, function (\App\Task $task) {
        return [
            'id' =&gt; $task-&gt;id,
            'text' =&gt; $task-&gt;text,
            'is_completed' =&gt; $task-&gt;is_completed ? 'yes' : 'no'
        ];
    });
    //Manager,主要管理要将数据格式化为哪一种格式
    $fractal = new \League\Fractal\Manager();
    return $fractal-&gt;createData($resource)-&gt;toJson();
});
</code></pre>
<h4 id="三种数据结构">三种数据结构</h4>
<p><code>ArraySerializer</code>、<code>DataArraySerializer</code>、<code>JsonApiSerializer</code>三种序列化器</p>
<ol>
<li><code>ArraySerializer</code></li>
</ol>
<pre><code class="language-php">Route::get('/fractal/serializers', function () {
    $task = \App\Task::findOrFail(1);
    $resource = new \League\Fractal\Resource\Item($task, function (\App\Task $task) {
        return [
            'id' =&gt; $task-&gt;id,
            'text' =&gt; $task-&gt;text,
            'is_completed' =&gt; $task-&gt;is_completed ? 'yes' : 'no'
        ];
    });
    $fractal = new \League\Fractal\Manager();
    $fractal-&gt;setSerializer(new \League\Fractal\Serializer\ArraySerializer());
    return $fractal-&gt;createData($resource)-&gt;toJson();
});
</code></pre>
<figure data-type="image" tabindex="3"><img src="assets/1558154981808.png" alt="1558154981808" loading="lazy"></figure>
<ol start="2">
<li>
<p><code>DataArraySerializer</code></p>
<blockquote>
<p>DataArraySerializer 是Fractal默然的数据输出格式,与ArraySerializer相比,多出了一层data包裹</p>
</blockquote>
</li>
</ol>
<pre><code class="language-php">$fractal-&gt;setSerializer(new \League\Fractal\Serializer\DataArraySerializer());
</code></pre>
<figure data-type="image" tabindex="4"><img src="assets/1558155166061.png" alt="1558155166061" loading="lazy"></figure>
<ol start="3">
<li>
<p><code>JsonApiSerializer</code></p>
<pre><code class="language-php">$fractal-&gt;setSerializer(new \League\Fractal\Serializer\JsonApiSerializer());
</code></pre>
<figure data-type="image" tabindex="5"><img src="assets/1558155367779.png" alt="1558155367779" loading="lazy"></figure>
</li>
</ol>
<h4 id="转换器">转换器</h4>
<blockquote>
<p>转化器类必须继承自 <code>League\Fractal\TransformerAbstract</code> 基类，并且至少实现 <code>transform()</code> 方法。我们在代码任务项目中创建一个保存在 <code>app/Transformers</code> 目录下的转化器类 <code>TaskTransformer</code>，并初始化代码如下</p>
</blockquote>
<pre><code class="language-php">&lt;?php
namespace App\Transformers;
use App\Task;
use League\Fractal\TransformerAbstract;

class TaskTransformer extends TransformerAbstract
{
    public function transform(Task $task)
    {
        return [
            'id' =&gt; $task-&gt;id,
            'text' =&gt; $task-&gt;text,
            //需要注意一些敏感信息,如用户手机,微信的union_id等,我们可以使用另外的字段返回
            'phone'=&gt;$task-&gt;phone?true:false,
            'completed' =&gt; $task-&gt;is_completed ? 'yes' : 'no',
            'link' =&gt; route('tasks.show', ['id' =&gt; $task-&gt;id])
        ];
    }
}
</code></pre>
<p>这样一来，我们就可以改写之前的资源转化代码如下：</p>
<pre><code class="language-php">// 获取单个资源
$task = \App\Task::findOrFail(1);
$resource = new \League\Fractal\Resource\Item($task, new \App\Transformers\TaskTransformer());

// 获取资源集合
$tasks = \App\Task::all();
$resources = new \League\Fractal\Resource\Collection($tasks, new \App\Transformers\TaskTransformer());
</code></pre>
<p><strong>关联模型数据</strong></p>
<p>除此之外，我们还可以在模型字段之外，引入额外的数据，比如关联模型：</p>
<pre><code>&lt;?php

namespace App\Transformers;

use App\Task;
use League\Fractal\TransformerAbstract;

class TaskTransformer extends TransformerAbstract
{
    protected $availableIncludes = ['user'];

    public function transform(Task $task)
    {
        return [
            'id' =&gt; $task-&gt;id,
            'text' =&gt; $task-&gt;text,
            'completed' =&gt; $task-&gt;is_completed ? 'yes' : 'no',
            'link' =&gt; route('tasks.show', ['id' =&gt; $task-&gt;id])
        ];
    }

    public function includeUser(Task $task)
    {
        $user = $task-&gt;user;
        return $this-&gt;item($user, new UserTransformer());
    }
}
</code></pre>
<p>由于在上述代码中引入了新的转化器类 <code>UserTransformer</code>，所以需要创建它：</p>
<pre><code>&lt;?php

namespace App\Transformers;

use App\User;
use League\Fractal\TransformerAbstract;

class UserTransformer extends TransformerAbstract
{
    public function transform(User $user)
    {
        return [
            'id' =&gt; $user-&gt;id,
            'name' =&gt; $user-&gt;name
        ];
    }
}
</code></pre>
<p>然后修改返回响应数据代码如下，通过 <code>parseIncludes</code> 方法引入要包含的额外字段：</p>
<pre><code>return $fractal-&gt;parseIncludes('user')-&gt;createData($resource)-&gt;toJson();
</code></pre>
<p>这样一来，就可以在返回的响应数据中看到 <code>user</code> 字段了：</p>
<figure data-type="image" tabindex="6"><img src="assets/546fc78b6e238ab7558082109660f566.jpg" alt="img" loading="lazy"></figure>
<h3 id="数据格式切换组件">数据格式切换组件</h3>
<h4 id="名称-liyu001989dingo-serializer-switch">名称: <a href="https://github.com/liyu001989">liyu001989</a>/<strong>dingo-serializer-switch</strong></h4>
<blockquote>
<p>参考一下该组件,做laravel的扩展组件</p>
</blockquote>
<h4 id="使用-2">使用</h4>
<pre><code class="language-php">//routes/api.php
$api-&gt;version('v1',['middleware'=&gt;'serialize:array'])
</code></pre>
<h2 id="http基础">HTTP基础</h2>
<h3 id="http-提交数据的两种方式">http 提交数据的两种方式</h3>
<p>application/x-www-form-urlencoded(默认值)<br>
multipart/form-data</p>
<p>需要明确的是，只有当 POST 配合  multipart/form-data  时才能正<br>
确传输文件。</p>
<h2 id="帖子数据">帖子数据</h2>
<h3 id="修改话题">修改话题</h3>
<pre><code class="language-php">//修改话题
$api-&gt;patch('topics/{topic}','TopicsController@update')-&gt;name('api.topics.update');
</code></pre>
<blockquote>
<p>这里需要注意的是由于路由交给DingoApi来处理了,所以调至路由模型绑定出了问题.所以模型绑定的中间件没有注册上,需要手动增加bindings中间件</p>
</blockquote>
<pre><code class="language-php">$api-&gt;version('v1', [
    'namespace' =&gt; 'App\Http\Controllers\Api',
    //这里增加bindings
    'middleware' =&gt; ['serializer:array','bindings']
])
</code></pre>
<h4 id="dingoapi手动处理异常">dingoApi手动处理异常</h4>
<pre><code class="language-php">//app/Providers/AppServiceProvider.php
</code></pre>
<pre><code class="language-php">public function register()
{
    \API::error(function (\Illuminate\Auth\Access\AuthorizationException $exception) {
        abort(403, $exception-&gt;getMessage());
    });
    \API::error(function  (\Symfony\Component\HttpKernel\Exception\NotFoundHttpException  $exception)  {
        throw  new  \Symfony\Component\HttpKernel\Exception\HttpException(404,  '404 Not Found');
    });
}
</code></pre>
<h3 id="日志查询组件">日志查询组件</h3>
<p><code>laravel-query-logger</code></p>
<h4 id="安装">安装</h4>
<pre><code class="language-php">composer require overtrue/laravel-query-logger --dev
</code></pre>
<blockquote>
<p>只有当APP_DEBUG为true 时才能使用</p>
</blockquote>
<h2 id="消息接口">消息接口</h2>
<h2 id="本地化">本地化</h2>
<h3 id="思路1">思路1:</h3>
<p>增加自定义code码</p>
<pre><code class="language-php">use Symfony\Component\HttpKernel\Exception\HttpException;

class Controller extends BaseController
{
    //引入dingo的部分方法
    use Helpers;
	//自定义异常处理
    public function errorResponse($statusCode,$message=null,$code=0)
    {
        throw new HttpException($statusCode,$message,null,[],$code);
    }
}
</code></pre>
<h3 id="思路2">思路2:</h3>
<blockquote>
<p>利用HTTP的Accept-language 头信息</p>
<p>Accept-Language zh-CN	简体中文</p>
<p>Accept-Language en 英文</p>
</blockquote>
<h4 id="步骤-2">步骤:</h4>
<ol>
<li><strong>创建编辑中间件changeLocale</strong></li>
</ol>
<pre><code class="language-php">class ChangeLocale
{
    public function handle($request, Closure $next)
    {
        $language=$request-&gt;header('accept-language');
        if($language){
            \App::setLocale($language);
        }
        return $next($request);
    }
}
</code></pre>
<ol start="2">
<li>
<p><strong>注册中间件</strong></p>
<p><code>app/Http/Kernel.php</code></p>
</li>
</ol>
<pre><code class="language-php">'change-locale'=&gt;\App\Http\Middleware\ChangeLocale::class,
</code></pre>
<ol start="3">
<li><strong>路由设置中间件</strong></li>
</ol>
<pre><code class="language-php">$api-&gt;version('v1', [
    'namespace' =&gt; 'App\Http\Controllers\Api',
    'middleware' =&gt; ['serializer:array','bindings','change-locale']
]
</code></pre>
<ol start="4">
<li>使用案例</li>
</ol>
<pre><code class="language-php">if (!$token = \Auth::guard('api')-&gt;attempt($credentials)) {
	return $this-&gt;response-&gt;errorUnauthorized(trans('auth.failed'));
}
</code></pre>
<h2 id="api测试和文档">API测试和文档</h2>
<h3 id="phpunit-测试">phpunit 测试</h3>
<h4 id="windows下安装">windows下安装</h4>
<blockquote>
<p>虽然laravel框架内置了phpunit,但是不能使用,直接在项目中输入phpunit 会显示 command not found</p>
</blockquote>
<ol>
<li>
<p>删除vendor 文件夹,然后重新composer update</p>
</li>
<li>
<p>输入以下命令引入phpunit包</p>
<pre><code class="language-php">$ composer global require phpunit/phpunit
</code></pre>
<p><code>omposer global remove phpunit/phpunit</code> phpunit包的删除命令</p>
</li>
<li>
<p>配置环境变量</p>
<p>phpunit命令的存放目录: D:\wamp64\www\question_bank\vendor\bin</p>
</li>
</ol>
<h4 id="单元测试">单元测试</h4>
<ol>
<li>创建测试文件</li>
</ol>
<pre><code class="language-php">php artisan make:test TopicApiTest
</code></pre>
<p>该命令会在tests/Feature目录中创建TopicApiTest.php文件</p>
<ol start="2">
<li>测试发布话题</li>
</ol>
<pre><code class="language-php">       //setUp方法在测试开始前执行,先创建一个用户
   public function setUp(): void
       {
           parent::setUp(); // TODO: Change the autogenerated stub
           $this-&gt;user = factory(User::class)-&gt;create();
       }
   
       public function testStoreTopic()
       {
           $data = ['category_id' =&gt; 1, 'body' =&gt; 'test body', 'title' =&gt; 'test title'];
           $token=\Auth::guard('api')-&gt;fromUser($this-&gt;user);
           //$this-&gt;json可以方便的模拟各种http请求,第一个参数:请求的方法,第二个参数:请求地址,第三个参数:请求参数,第四个参数:请求header,利用withHeaders方法也可以
           $response=$this-&gt;withHeaders(['Authorization'=&gt;'Bearer'.$token])-&gt;json('POST','/api/topics',$data);
   
           $assertData = [
               'category_id' =&gt; 1,
               'user_id' =&gt; $this-&gt;user-&gt;id,
               'title' =&gt; 'test title',
               'body' =&gt; clean('test body', 'user_topic_body')
           ];
           //通过assertStatus,断言响应结果为201，通过assertJsonFragment,断言响应结果包含assertData数据。
           $response-&gt;assertStatus(201)-&gt;assertJsonFragment($assertData);
       }
</code></pre>
<ol start="3">
<li>
<p>执行测试</p>
<pre><code class="language-php">$ phpunit
</code></pre>
</li>
</ol>
<h3 id="第三方黑盒测试-postman">第三方黑盒测试 [postman]</h3>
<ol>
<li>
<p>导出导入collections和环境变量</p>
</li>
<li>
<p>编写测试用例</p>
</li>
</ol>
<figure data-type="image" tabindex="7"><img src="E:%5CNutCloud%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Claravel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cassets%5C1562227821519.png" alt="1562227821519" loading="lazy"></figure>
<ol start="3">
<li>批量测试</li>
</ol>
<h3 id="api-文档">api 文档</h3>
<p><a href="https://apizza.net/">https://apizza.net</a></p>
<h2 id="passport使用">passport使用</h2>
<h3 id="安装和设置">安装和设置</h3>
<p>1.composer 安装</p>
<pre><code class="language-php">composer require laravel/passport
</code></pre>
<p>2.生成数据表<br>
<code>migrate</code></p>
<ol start="3">
<li>创建加密秘匙</li>
</ol>
<pre><code class="language-php">php artisan passport:keys
</code></pre>
<ol start="4">
<li>创建客户端</li>
</ol>
<pre><code class="language-php">php artisan passport:client --password --name='larabbs-ios'
</code></pre>
<h3 id="passport调试">passport调试</h3>
<h4 id="1注册路由">1.注册路由</h4>
<p>app/Providers/AuthServiceProvider.php</p>
<pre><code class="language-php">    public function boot()
    {
        //Passport的路由
        Passport::routes();
        //access_token过期时间
        Passport::tokensExpireIn(Carbon::now()-&gt;addDays(15));
        //refreshTokens 刷星过期时间
        Passport::refreshTokensExpireIn(Carbon::now()-&gt;addDays(30));
</code></pre>
<h4 id="2-获取访问令牌">2. 获取访问令牌</h4>
<p><img src="assets/20190705164343875_11189.png" alt="" loading="lazy"><br>
<strong>参数列表</strong><br>
grant_type —— 密码模式固定为    password  ；<br>
client_id —— 通过    passport:client   创建的客户端  id  ；<br>
client_secret —— 通过    passport:client   创建的客户端  secret  ；<br>
username —— 登录的用户名，数据库中任意用户邮箱；<br>
password —— 用户密码；<br>
scope —— 作用域，可填写    *   或者为空；<br>
<strong>获取的信息</strong><br>
token_type —— 令牌类型；<br>
expires_in—— 多长时间后过期；<br>
access_token —— 访问令牌；<br>
refresh_token —— 刷新令牌；<br>
<img src="assets/20190705164603055_29633.png" alt="" width="593" loading="lazy"></p>
<h4 id="获取登录用户信息">获取登录用户信息</h4>
<p>1.修改user模型 添加  Laravel\Passport\HasApiTokens   Trait<br>
2.修改auth配置,将api guard的driver由jwt 修改为passport<br>
3.增加一个PassportDingoProvider,因为DingoApi没有做passport的适配.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[larachina02 学习笔记]]></title>
        <id>https://bluegrasses.github.io/post/larachina02-xue-xi-bi-ji/</id>
        <link href="https://bluegrasses.github.io/post/larachina02-xue-xi-bi-ji/">
        </link>
        <updated>2020-11-01T23:08:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="汇总知识">汇总知识</h2>
<h3 id="模型关联括号">模型关联括号</h3>
<p>模型关联什么时候加括号，什么时候不加括号 ?</p>
<blockquote>
<p>加括号是关系, 不加是对象或者对象集合</p>
</blockquote>
<h2 id="第二章-舞台布置">第二章: 舞台布置</h2>
<h3 id="字体图标">字体图标</h3>
<p><a href="https://www.npmjs.com/package/@fortawesome/fontawesome-free">@fortawesome/fontawesome-free</a></p>
<h4 id="载入样式">载入样式</h4>
<p>resources/sass/app.scss</p>
<pre><code class="language-php">// Fontawesome
@import '~@fortawesome/fontawesome-free/scss/fontawesome';
@import '~@fortawesome/fontawesome-free/scss/regular';
@import '~@fortawesome/fontawesome-free/scss/solid';
@import '~@fortawesome/fontawesome-free/scss/brands';
</code></pre>
<h2 id="第三章-用户中心">第三章: 用户中心</h2>
<h3 id="guest使用">@guest使用</h3>
<pre><code class="language-html">@guest
&lt;li&gt;登录&lt;/li&gt;
&lt;li&gt;注册&lt;/li&gt;
@else
个人中心
编辑资料
@endguest
</code></pre>
<h3 id="验证码">验证码</h3>
<p><code>mewebstudio/captcha</code></p>
<blockquote>
<p>In Windows, you'll need to include the GD2 DLL <code>php_gd2.dll</code> in php.ini. And you also need include <code>php_fileinfo.dll</code>and <code>php_mbstring.dll</code> to fit the requirements of <code>mews/captcha</code>'s dependencies.</p>
</blockquote>
<p>基本使用</p>
<pre><code class="language-html">&lt;img src=&quot;{{captcha_src('flat')}}&quot;&gt;
</code></pre>
<h3 id="邮箱验证">邮箱验证</h3>
<ol>
<li>修改user模型</li>
</ol>
<pre><code class="language-php">use Illuminate\Auth\MustVerifyEmail as MustVerifyEmailTrait;
use Illuminate\Contracts\Auth\MustVerifyEmail as MustVerifyEmailContract;
class User extends Authenticatable implements MustVerifyEmailContract
{
	use Notifiable, MustVerifyEmailTrait;
</code></pre>
<ol start="2">
<li>
<p>强制用户认证</p>
<p>(1) 建立中间件</p>
</li>
</ol>
<pre><code class="language-php">// app\Http\Middleware\EnsureEmailIsVerified.php
class EnsureEmailIsVerified
{
    public function handle($request, Closure $next)
    {
        // 三个判断：
        // 1. 如果用户已经登录
        // 2. 并且还未认证 Email
        // 3. 并且访问的不是 email 验证相关 URL 或者退出的 URL。

        if($request-&gt;user()&amp;&amp;!$request-&gt;user()-&gt;hasVerifiedEmail()&amp;&amp;!$request-&gt;is('email/*','logout')){
            //判断是不是json响应
            return  $request-&gt;expectsJson()?abort(403,'Your email address is not verified.'):redirect()-&gt;route('verification.notice');
        }
        return $next($request);
    }
}
</code></pre>
<p>(2) 注册中间件</p>
<pre><code class="language-php">// app/Http/Kernel.php
    protected $middlewareGroups = [
    'web' =&gt; [
        \App\Http\Middleware\EncryptCookies::class,
        \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
        \Illuminate\Session\Middleware\StartSession::class,
        //注意需要在startSession中间件之后
        \App\Http\Middleware\EnsureEmailIsVerified::class, 
</code></pre>
<h3 id="事件和监听器基本流程">事件和监听器基本流程</h3>
<blockquote>
<p>应用场景:邮箱认证后的消息提示</p>
</blockquote>
<h4 id="存放目录">存放目录</h4>
<p>事件类存放在app/Events</p>
<p>事件类的监听器存放在app/Listeners中.</p>
<h4 id="注册事件和监听器">注册事件和监听器</h4>
<p><code>EventServiceProvider</code></p>
<pre><code class="language-php">protect $listen=[
  'App\Events\OrderShipped' =&gt; [
          'App\Listeners\SendShipmentNotification',
      ],
]
</code></pre>
<h4 id="生成事件监听器">生成事件&amp;监听器</h4>
<pre><code class="language-php">php artisan event:generate
</code></pre>
<h4 id="定义事件和监听器">定义事件和监听器</h4>
<p><code>定义事件</code></p>
<pre><code class="language-php">namespace App\Events;
use App\Order;
use Illuminate\Queue\SerializesModels;
class OrderShipped
{
    use SerializesModels;
    public $order;
    public function __construct(Order $order)
    {
        $this-&gt;order = $order;
    }
}
</code></pre>
<p><code>定义监听器</code></p>
<pre><code class="language-php">namespace App\Listeners;
use App\Events\OrderShipped;
class SendShipmentNotification
{
    public function __construct()
    {
    }
    /**
     * 处理事件。
     * @param  \App\Events\OrderShipped  $event
     * @return void
     */
    public function handle(OrderShipped $event)
    {
        // 使用 $event-&gt;order 来访问 order …
    }
}
</code></pre>
<h4 id="分发事件">分发事件</h4>
<pre><code class="language-php">class OrderController extends Controller
{
    /**
     * 将传递过来的订单发货。
     * @param  int  $orderId
     * @return Response
     */
    public function ship($orderId)
    {
        $order = Order::findOrFail($orderId);
        // 订单发货逻辑…
        event(new OrderShipped($order));
    }
}
</code></pre>
<h3 id="密码重置提示">密码重置提示</h3>
<p>涉及知识点 , trait方法重写</p>
<h2 id="第四章-用户中心">第四章: 用户中心</h2>
<h3 id="unique-验证规则">unique 验证规则</h3>
<blockquote>
<p>场景: 用户在编辑自身资料时, 如未修改唯一字段email, 提交时会报错email已存在. 需要在unique判断时排除自身</p>
</blockquote>
<pre><code class="language-php">//unique 第一个参数表名 第二参数字段名 第三个参数排除的数据
'email'=&gt;'requried|unique:users,eamil,'.\Auth::id()
</code></pre>
<h3 id="中文显示友好时间戳">中文显示友好时间戳</h3>
<p>基本操作</p>
<pre><code class="language-php">$user-&gt;created_at-&gt;diffForHumans()
</code></pre>
<blockquote>
<p>Carbon 是 php知名的时间和日期扩展,laravel 将其默认集成到框架中.diffForHumans()就是carbon对象提供的方法,默认情况下是英文的.</p>
</blockquote>
<p>修改为中文</p>
<pre><code class="language-php">app/Providers/AppServiceProvider.php
public function boot(){	
    \Carbon\Carbon::setLocale('zh');
}
</code></pre>
<h3 id="头像上传">头像上传</h3>
<h4 id="图片验证规则">图片验证规则</h4>
<pre><code class="language-php">'avatar'=&gt;'mimes:jpeg,bmp,png,gif|dimensions:min_width=208,min_heigth=208'
</code></pre>
<h4 id="裁剪图片">裁剪图片</h4>
<p>用户有时候会上传分辨率较大的图片,图片太大会拖慢页面的加载速度,所以接下来我们将对此进行优化.</p>
<p>插件名称: Intervention/image</p>
<p>https://github.com/Intervention/image</p>
<h3 id="个人资料编辑存在的问题">个人资料编辑存在的问题</h3>
<h4 id="1-游客限制">1. 游客限制</h4>
<p>解决方法: 中间件</p>
<pre><code class="language-php">public function __construct(){
    $this-&gt;middleware('auth');
}
</code></pre>
<h4 id="2修改别人的资料平行权限">2.修改别人的资料(平行权限)</h4>
<p>解决方法: 策略</p>
<p>(1) 生成策略,编写规则</p>
<p>(2) 注册策略</p>
<p>(3) 使用策略授权动作</p>
<h2 id="第五章-帖子列表">第五章 帖子列表</h2>
<p>建立模型同时建立数据迁移文件 -m 参数</p>
<pre><code class="language-php">php artisan make:model Models/Category -m
</code></pre>
<h3 id="初始化数据">初始化数据</h3>
<blockquote>
<p>用数据迁移来解决初始化数据,而不是使用模型工厂factory</p>
<p>用数据迁移来初始化数据</p>
<p>用模型工厂来生成测试数据</p>
</blockquote>
<p>解决方法: 数据迁移</p>
<p>我们定义的命名规范为seed_ (数据库名称) _data</p>
<pre><code class="language-php">php artisan make:migration seed_categories_data
</code></pre>
<p>数据迁移文件</p>
<pre><code class="language-php">public function up()
{
    $categories = [
        [
            'name' =&gt; '分享',
            'description' =&gt; '分享创造,分享发现',
        ],
        [
            'name' =&gt; '教程',
            'description' =&gt; '开发技巧,推荐扩展包等',
        ]
    ];
    //
    DB::table('categories')-&gt;insert($categories);
}

public function down()
{
    //
    DB::table('categories')-&gt;truncate();
}
</code></pre>
<h3 id="代码生成器">代码生成器</h3>
<p>laravel 项目开发规范</p>
<p>https://learnku.com/docs/laravel-specification/5.5</p>
<p>插件名称: <code>summerblue/generator</code></p>
<h4 id="使用案例">使用案例</h4>
<pre><code class="language-php">//schema 后面的参数是数据库的字段描述
php artisan make:scaffold Topic --schema=&quot;name:string:index,description:text:nullable,subscriber_count:integer:unsigned:default(0)&quot;
</code></pre>
<h4 id="生成的代码">生成的代码</h4>
<ol>
<li>生成数据库迁移文件</li>
<li>创建数据工厂文件 TopicFactory.php</li>
<li>创建数据填充文件 TopicTableSeeder.php</li>
<li>创建模型基类文件和数据模型 Model.php Topic.php</li>
<li>创建控制 TopicsController.php</li>
<li>创建表单请求的基类文件 Request.php 并创建TopicRequest.php验证类</li>
<li>创建模型时间监控器,并在AppServiceProvider中注册 TopicObserver</li>
<li>创建授权策略基类 Policy.php 同时创建话题授权类TopicPolicy.php，并在AuthServiceProvider 中注册</li>
<li>在web.php中更新路由, 新增Topics资源路由</li>
<li>新建符合资源控制器的三个话题视图文件,并存放于resources/views/topics 目录;</li>
<li>执行数据库迁移命令 artisan migrate</li>
<li>执行composer dump-autoload 来生成classmap</li>
</ol>
<h3 id="git-使用案例">git 使用案例</h3>
<pre><code class="language-php">//撤销所有文件修改操作
git checkout .
//删除文件,删除add还是commit,不确定?
//-f 强制清理文件的设置 -d 连文件夹也删除
git clean -f -d
</code></pre>
<h3 id="数据填充">数据填充</h3>
<blockquote>
<p>Faker 假数据生成库</p>
<p>fzaninotto/faker</p>
</blockquote>
<p>生成laravel 的时间戳</p>
<p>'create_at'=&gt;<span class='katex-error' title='ParseError: KaTeX parse error: Double superscript at position 15: faker-&gt;data.&#039; &#039;̲.'>faker-&gt;data.&#039; &#039;.</span>faker-&gt;time;</p>
<h4 id="数据填充的基本流程">数据填充的基本流程</h4>
<ol>
<li>
<p>数据模型 Topic.php</p>
</li>
<li>
<p>数据工厂 database/factories/UserFactory.php</p>
</li>
<li>
<p>数据填充 database/seeds/UsersTableSeeder.php</p>
</li>
<li>
<p>注册数据填充 database/seeds/DatabaseSeeder.php</p>
</li>
</ol>
<p>使用案例:</p>
<ol>
<li>建立模型工厂</li>
</ol>
<pre><code class="language-php">// 1. UserFactory.php
$factory-&gt;define(App\Models\User::class, function (Faker $faker) {
    $data_time=$faker-&gt;date.' '.$faker-&gt;time;
    return [
        'name' =&gt; $faker-&gt;name,
        'email' =&gt; $faker-&gt;unique()-&gt;safeEmail,
        'email_verified_at' =&gt; now(),
        'password' =&gt; bcrypt('welcome'), // secret
        'remember_token' =&gt; str_random(10),
        'userinfo'=&gt;$faker-&gt;sentence(),
        'created_at'=&gt;$data_time,
        'updated_at'=&gt;$data_time,
    ];
}); 
</code></pre>
<ol start="2">
<li>建立seeder</li>
</ol>
<pre><code class="language-php">// 2. UsersTableSeeder.php
    public function run()
    {
        //获取faker实例
        $faker=app(Faker\Generator::class);
        $avatars=[
'https://iocaffcdn.phphub.org/uploads/images/201710/14/1/xAuDMxteQy.png',
'https://iocaffcdn.phphub.org/uploads/images/201710/14/1/ZqM7iaP4CR.png',
'https://iocaffcdn.phphub.org/uploads/images/201710/14/1/NDnzMutoxX.png',
        ];
        //生成数据集合 times为生成数量 make生成
        $users=factory(\App\Models\User::class)-&gt;times(10)-&gt;make()-&gt;each(function($user,$index) use($faker,$avatars){
            //从头像中随机取出一个并赋值
            $user-&gt;avatar=$faker-&gt;randomElement($avatars);
        });
        //让隐藏字段可见, 并将数据集合转换为数值
        $user_array=$users-&gt;makeVisible(['password','remember_token'])-&gt;toArray();
        //插入到数据库中
        \App\Models\User::insert($user_array);

        //单独更新第一个用户的数据
        $user=\App\Models\User::find(1);
        $user-&gt;name='admin';
        $user-&gt;email='admin@126.com';
        $user-&gt;avatar='https://iocaffcdn.phphub.org/uploads/images/201710/14/1/ZqM7iaP4CR.png';
        $user-&gt;save();
    }
</code></pre>
<ol start="3">
<li>在DatabaseSeeder中注册seeder</li>
</ol>
<pre><code class="language-php">// DatabaseSeeder.php
use Illuminate\Database\Seeder;
class DatabaseSeeder extends Seeder
{
    public function run()
    {
        $this-&gt;call(UsersTableSeeder::class);
    }
}
</code></pre>
<ol start="4">
<li>
<p>执行填充</p>
<pre><code class="language-php">php artisan migrate:refresh --seed
</code></pre>
</li>
</ol>
<h3 id="懒加载">懒加载</h3>
<p>解决n+1 的问题</p>
<pre><code class="language-php">// n+1 产生的场景
&lt;ul class=&quot;media-list&quot;&gt;
@foreach($topics as $topic)
{{$topic-&gt;user-&gt;name}}
{{$topic-&gt;category-&gt;name}}
@endforeach
&lt;/ul&gt;

 解决:
//with 懒加载 in语句
$topics=Topic::with('user','category')-&gt;paginate();
执行sql 语句:
select * form `user` where `user`.`id` in (1,2,4,5,6);

</code></pre>
<h3 id="标题模板三元表达式">标题模板三元表达式</h3>
<pre><code class="language-php">@section('title', isset($category)?$category-&gt;name:'话题列表')
</code></pre>
<h3 id="导航栏-active-类设置">导航栏 active 类设置</h3>
<h4 id="插件名称">插件名称</h4>
<p><code>letrunghieu/active</code></p>
<pre><code class="language-php">composer require &quot;hieu-le/active:~3.5&quot;
</code></pre>
<h4 id="基础语法">基础语法</h4>
<ol>
<li>if_route() - 判断当前对应的路由是否是指定的路由；</li>
<li>if_route_param() - 判断当前的 url 有无指定的路由参数。</li>
<li>if_query() - 判断指定的 GET 变量是否符合设置的值；</li>
<li>if_uri() - 判断当前的 url 是否满足指定的 url；</li>
<li>if_route_pattern() - 判断当前的路由是否包含指定的字符；</li>
<li>if_uri_pattern() - 判断当前的 url 是否含有指定的字符；</li>
</ol>
<h4 id="使用案例-2">使用案例</h4>
<p>案例1 :</p>
<pre><code class="language-php+html">/**设置 激活类
 * @param $routerName 路由名称
 * @param $param 地址栏参数
 * @param $param_id 参数值(id)
 * @return string 成功返回类名active,否则为''.
 */
function set_active_class($routerName,$param,$param_id)
{
    return active_class((if_route($routerName)&amp;&amp;if_route_param($param,$param_id)));
}

使用:
&lt;li class=&quot;nav-item {{active_class(if_route('topics.index'))}}&quot;&gt;
    &lt;a class=&quot;nav-link&quot; href=&quot;{{route('topics.index')}}&quot;&gt;话题 &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;li class=&quot;nav-item {{set_active_class('categories.show','category',1)}}&quot;&gt;
    &lt;a class=&quot;nav-link&quot; href=&quot;{{route('categories.show',1)}}&quot;&gt;分享&lt;/a&gt;
&lt;/li&gt;
</code></pre>
<p>案例2 :</p>
<pre><code class="language-html">//if_query 判断参数order是否值为recent
&lt;li class=&quot;nav-item&quot;&gt;&lt;a class=&quot;nav-link {{active_class(!if_query('order','recent'))}}&quot; href=&quot;{{Request::url()}}?order=default&quot;&gt;最后回复&lt;/a&gt;&lt;/li&gt;

&lt;li class=&quot;nav-item&quot;&gt;&lt;a class=&quot;nav-link {{active_class(if_query('order','recent'))}}&quot; href=&quot;{{Request::url()}}?order=recent&quot;&gt;最新发布&lt;/a&gt;&lt;/li&gt;


</code></pre>
<h3 id="模板include变量分配">模板include变量分配</h3>
<blockquote>
<p>场景: 用户中心的文章列表</p>
</blockquote>
<pre><code class="language-html">@include('user._topics',['topics'=&gt;$user-&gt;topics()-&gt;recent()-&gt;paginate(5)])
</code></pre>
<h2 id="第六章-帖子curd">第六章 帖子CURD</h2>
<h3 id="模型观察器处理摘要">模型观察器处理摘要</h3>
<h4 id="eloquent-事件">Eloquent 事件</h4>
<table>
<thead>
<tr>
<th>事件</th>
<th>触发时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>creating</td>
<td>当一个新模型被初次保存将会触发</td>
</tr>
<tr>
<td>created</td>
<td>当一个新模型被初次保存将会触发</td>
</tr>
<tr>
<td>updated</td>
<td>如果一个模型已经存在于数据库且调用了save方法</td>
</tr>
<tr>
<td>updating</td>
<td>如果一个模型已经存在于数据库且调用了save方法</td>
</tr>
<tr>
<td>saving</td>
<td>保存到数据库后触发（插入/更新之后，无论插入还是更新都会触发）</td>
</tr>
<tr>
<td>saved</td>
<td>保存到数据库后触发（插入/更新之后，无论插入还是更新都会触发）</td>
</tr>
</tbody>
</table>
<h4 id="应用场景">应用场景</h4>
<blockquote>
<p>摘要根据文章内容自动生成</p>
</blockquote>
<pre><code class="language-php">//观察器
class TopicObserver
{

    public function saving(Topic $topic)
    {
        $topic-&gt;excerpt=make_excerpt($topic-&gt;body);
    }
}

//helpers.php 函数
/**
 * 生成摘要函数
 * @param $value  生成摘要的值
 * @param int $length  生成摘要的长度
 * @return string
 */
function make_excerpt($value,$length=200)
{
    $excerpt=trim(preg_replace('/\r\n|\r|\n+/','',strip_tags($value)));
    return str_limit($excerpt,$length);
}

/*注册观察器
app/Providers/EventServiceProvider.php
*/
public function boot()
{
    parent::boot();
    Topic::observe(TopicObserver::class);
}
</code></pre>
<h3 id="simditor-编辑器">Simditor 编辑器</h3>
<h4 id="安装">安装</h4>
<p>下载simditor压缩包</p>
<p>将下载的 simditor.css 放置于 resources/editor/css 文件夹，将 hotkeys.js , odule.js ,simditor.js , uploader.js 四个文件放置于 resources/editor/js 文件夹中</p>
<pre><code class="language-php">//复制目录到public目录
mix.js('resources/js/app.js', 'public/js')
.sass('resources/sass/app.scss', 'public/css')
.copyDirectory('resources/editor/js', 'public/js')
.copyDirectory('resources/editor/css', 'public/css')
</code></pre>
<h4 id="加载">加载</h4>
<pre><code class="language-javascript">@section('styles')
 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;{{ asset('css/simditor.css') }}&quot;&gt;
@endsection

@section('scripts')
 &lt;script type=&quot;text/javascript&quot; src=&quot;{{ asset('js/module.js') }}&quot;&gt;&lt;/script&gt;
 &lt;script type=&quot;text/javascript&quot; src=&quot;{{ asset('js/hotkeys.js') }}&quot;&gt;&lt;/script&gt;
 &lt;script type=&quot;text/javascript&quot; src=&quot;{{ asset('js/uploader.js') }}&quot;&gt;&lt;/script&gt;
 &lt;script type=&quot;text/javascript&quot; src=&quot;{{ asset('js/simditor.js') }}&quot;&gt;&lt;/script&gt;
 &lt;script&gt;
 $(document).ready(function() {
 var editor = new Simditor({
     //#editor为textarea 的id值
 textarea: $('#editor'),
 });
 });
 &lt;/script&gt;
@endsection
</code></pre>
<h4 id="图片上传">图片上传</h4>
<pre><code class="language-JavaScript">//前台配置    
&lt;script&gt;
        $(document).ready(function () {
            var editor = new Simditor({
                textarea: $('#editor'),
                upload: {
                    url: '{{route('topics.upload_image')}}',
                    params: {_token: '{{csrf_token()}}'},
                    //服务器获取图片的键值
                    fileKey: 'upload_file',
                    //最多只能同时上传3张图片
                    connectionCount: 3,
                    leaveConfirm: '文件上传中,关闭此页面将取消上传'
                },
				//是否允许粘贴
                pasteImage:true,
            });
        });
    &lt;/script&gt;
</code></pre>
<h3 id="xss-安全漏洞">xss 安全漏洞</h3>
<p>HTMLPurifier</p>
<p>HTMLPurifier for Laravel(<a href="https://github.com/mewebstudio">mewebstudio</a>/Purifier)</p>
<p>插件名称 : mewebstudio/Purifier</p>
<p>插件地址 : https://github.com/mewebstudio/Purifier</p>
<h4 id="安装-2">安装</h4>
<pre><code class="language-php">composer require mews/purifier
</code></pre>
<p>发布配置文件</p>
<pre><code class="language-php">php artisan vendor:publish --provider=&quot;Mews\Purifier\PurifierServiceProvider&quot;
</code></pre>
<h4 id="配置">配置</h4>
<pre><code class="language-php">'user_topic_body' =&gt; [
    'HTML.Doctype' =&gt; 'XHTML 1.0 Transitional',
    'HTML.Allowed' =&gt; 'div,b,strong,i,em,u,a[href|title],ul,ol,li,p[style],br,span[style],img[width|height|alt|src]',
    'CSS.AllowedProperties' =&gt; 'font,font-size,font-weight,font-style,font-family,text-decoration,padding-left,color,background-color,text-align',
    'AutoFormat.AutoParagraph' =&gt; true,
    'AutoFormat.RemoveEmpty' =&gt; true,
],
</code></pre>
<h4 id="使用">使用</h4>
<pre><code class="language-php">//user_topic_body 是上面配置项设置的键名
$topic-&gt;body=clean($topic-&gt;body,'user_topic_body');
</code></pre>
<h4 id="xss-注入测试">xss 注入测试</h4>
<blockquote>
<p>富文本器可以对部分安全进行转义,但是提交内容并不一定通过浏览器进行, 下面是通过谷歌浏览器控制台进行的一个简单的注入案例</p>
</blockquote>
<p>在谷歌浏览器控制台 console中键入下面代码:</p>
<p>//注意网址 token需要替换成自己的</p>
<p><strong>token 如何查看:</strong></p>
<p>查看网页源代码:</p>
<figure data-type="image" tabindex="1"><img src="assets/1553565430564.png" alt="1553565430564" loading="lazy"></figure>
<pre><code class="language-php">fetch(&quot;http://larachina02.com/topics&quot;, {&quot;headers&quot;:{&quot;content-type&quot;:&quot;application/x-www-form-urlencoded&quot;,&quot;upgrade-insecure-requests&quot;:&quot;1&quot;},&quot;body&quot;:&quot;_token=RiqfIdepmYfymLBuvh5dEJxQI1vO3vrgGYdCb2gv&amp;title=dangerous%20content+&amp;category_id=2&amp;body=%3Cscript%3Ealert%28%27%E5%AD%98%E5%9C%A8%20XSS%20%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81%EF%BC%81%27%29%3C%2Fscript%3E&quot;,&quot;method&quot;:&quot;POST&quot;,&quot;mode&quot;:&quot;cors&quot;});
</code></pre>
<p>上面代码会自动插入一片注入文章,点开该文章会有弹窗</p>
<h3 id="seo-友好的url">seo 友好的url</h3>
<blockquote>
<p>释义的 URL 有助于搜索引擎优化（SEO），本章节我们将开发自动生成 SEO 友好 URL 的功能。当用户提交发布话题的<br>
表单时，程序将调用 接口将话题标题翻译为英文，并储存于字段 slug 中。显示时候将 Slug 在 URL 中体现<br>
出来，假如话题标题为『Slug 翻译测试』的 URL 是：</p>
<p>http://larabbs.com/topics/119</p>
<p>加入 Slug 后 SEO 友好的链接为</p>
<p>http://larabbs.com/topics/119/slug-translation-test</p>
</blockquote>
<h4 id="安装的插件">安装的插件</h4>
<p><code>guzzlehttp/Guzzle</code></p>
<p>Guzzle库是一套强大的 PHP HTTP 请求套件，我们使用 Guzzle 的 HTTP 客户端来请求 接口。</p>
<p><code>overtrue\PinYin</code></p>
<p>PinYin是安正超开发的，基于cc-cedict 词典的中文转拼音工具，是一套优质的汉字转拼音解决方案。我们使用<br>
PinYin 来作为翻译的后备计划，当百度翻译 API 不可用时，程序会自动使用 PinYin 汉字转拼音方案来生成 Slug。</p>
<h4 id="注册百度翻译开放平台">注册百度翻译开放平台</h4>
<p>http://api.fanyi.baidu.com/api/trans/product/index</p>
<h4 id="翻译调用">翻译调用</h4>
<pre><code class="language-php">class TopicObserver
{

    public function saving(Topic $topic)
    {
        //入库时自动过滤
        $topic-&gt;body=clean($topic-&gt;body,'user_topic_body');
        //自动生成摘录
        $topic-&gt;excerpt=make_excerpt($topic-&gt;body);
        //seo 如slug字段无内容,即使使用翻译器对title进行翻译
        if(!$topic-&gt;slug){
            $topic-&gt;slug=app(SlugTranslateHandler::class)-&gt;translate($topic-&gt;title);
        }
    }
}
</code></pre>
<h3 id="laravel队列">laravel队列</h3>
<h4 id="队列步骤">队列步骤</h4>
<ol>
<li>配置队列安装驱动包</li>
<li>生成失败任务表</li>
<li>生成任务类</li>
<li>编辑任务类业务</li>
<li>任务分发</li>
<li>启动队列监控</li>
</ol>
<p><code>详细步骤</code></p>
<p>1.配置队列</p>
<blockquote>
<p>在使用之前必须安装redis软件</p>
</blockquote>
<p>安装redis队列驱动包</p>
<pre><code class="language-php">composer require &quot;predis/predis&quot;
</code></pre>
<p>.env</p>
<pre><code class="language-php">QUEUE_CONNECTION=redis
</code></pre>
<pre><code class="language-php">//redis配置
REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379
</code></pre>
<p>2.生成对列表</p>
<p>失败任务</p>
<p>有时候队列中的任务会失败。Laravel 内置了一个方便的方式来指定任务重试的最大次数。当任务超出这个重试次数后，它就会被插入到 failed_jobs 数据表里面。</p>
<pre><code class="language-php">//生成failed_jobs表
php artisan queue:failed-table
</code></pre>
<p>3.生成任务类</p>
<pre><code class="language-php">php artisan make:job TranslateSlug
</code></pre>
<p>4.修改任务类</p>
<blockquote>
<p>该类实现了 Illuminate\Contracts\Queue\ShouldQueue 接口，该接口表明 Laravel 应该将该任务添加到后台的任务队<br>
列中，而不是同步执行。</p>
<p>引入了 SerializesModels trait，Eloquent 模型会被优雅的序列化和反序列化。</p>
<p>handle 方法会在队列任务执行时被调用。</p>
<p>任务中要避免使用 Eloquent 模型接口调用，如： create() ,<br>
update() , save() 等操作。否则会陷入调用死循环--模型监控器分发任务，任务触发模型监控器，模型监控器再次分发任务，任务再次触发模型监控器.... 死循环。在这种情况下，使用 DB 类直接对数据库进行操作即可。</p>
</blockquote>
<p>5.任务分发</p>
<pre><code class="language-php">dispatch(new xxxjob($topic));
</code></pre>
<p>6.启动队列系统</p>
<p>php artisan queue:listen</p>
<h4 id="队列监控-horizon">队列监控 Horizon</h4>
<pre><code class="language-php">composer require laravel/horizon
</code></pre>
<blockquote>
<p>需要ext-pcntl 支持</p>
</blockquote>
<p><code>php artisan vendor:publish --provider=&quot;Laravel\Horizon\HorizonServiceProvide&quot;</code></p>
<h4 id="线上部署须知">线上部署须知</h4>
<ol>
<li>使用 Supervisor 进程工具进行管理，配置和使用请参照文档进行配置；</li>
<li>每一次部署代码时，需 artisan horizon:terminate 然后再 artisan horizon 重新加载代码。</li>
</ol>
<h2 id="第七章-帖子回复">第七章 帖子回复</h2>
<h3 id="tabs页面处理">tabs页面处理</h3>
<blockquote>
<p>基于 letrunghieu/active 插件</p>
</blockquote>
<h4 id="1active-类控制">1.active 类控制</h4>
<pre><code class="language-html">//href 传递一个tab参数,用于标志某个tabs
&lt;li class=&quot;nav-item&quot;&gt;
    &lt;a class=&quot;nav-link  bg-transparent {{active_class(if_query('tab',null))}}&quot; href=&quot;{{route('users.show',$user-&gt;id)}}&quot;&gt;Ta的话题&lt;/a&gt;
&lt;/li&gt;
&lt;li class=&quot;nav-item&quot;&gt;
    &lt;a class=&quot;nav-link {{active_class(if_query('tab','replies'))}}&quot; href=&quot;{{route('users.show',[$user-&gt;id,'tab'=&gt;'replies'])}}&quot;&gt;Ta的回复&lt;/a&gt;
&lt;/li&gt;
</code></pre>
<h4 id="2页面载入配置">2.页面载入配置</h4>
<pre><code class="language-php">@if(if_query('tab','replies'))
    {{--显示用户评论页--}}
    @include('ucenter.user._replies',['replies'=&gt;$user-&gt;reply()-&gt;with('topic')-&gt;recent()-&gt;paginate(5)])
@else
    {{--显示用户文章页--}}
    @include('ucenter.user._topics',['topics'=&gt;$user-&gt;topics()-&gt;recent()-&gt;paginate(5)])
@endif
</code></pre>
<h3 id="回复话题">回复话题</h3>
<pre><code class="language-html">//视条件加载子模板
@includeWhen($boolen,'view.name',['some'=&gt;'data'])
</code></pre>
<p>回复话题 ,回复数的增加 ReplyObserver 观察器</p>
<blockquote>
<p>比较严谨的做法是创建成功后计算本话题下评论总数, 然后在对其reply_count字段进行赋值。</p>
</blockquote>
<pre><code class="language-php">class ReplyObserver
{
     public function created(Reply $reply)
     {
         $reply-&gt;topic-&gt;reply_count = $reply-&gt;topic-&gt;replies-&gt;count();
         $reply-&gt;topic-&gt;save();
     }
}
</code></pre>
<h3 id="laravel-消息通知">laravel 消息通知</h3>
<h4 id="数据库通知知识">数据库通知知识</h4>
<ul>
<li>
<p>访问通知</p>
<p><code>$user-&gt;notifications</code></p>
</li>
<li>
<p>访问未读通知</p>
<p><code>$user-&gt;unreadNotifications</code></p>
</li>
<li>
<p>标记通知为已读</p>
<p><code>$user-&gt;markAsRead()</code></p>
</li>
<li>
<p>通知删除</p>
<p><code>$user-&gt;notifications()-&gt;delete();</code></p>
</li>
<li>
<p>获取data数据(json)</p>
<p><code>$notification-&gt;data['user_id']</code></p>
</li>
</ul>
<h4 id="通知频道">通知频道 :</h4>
<p>通知传播的途径, laravel自带的有数据库、邮件、短信以及slack</p>
<h4 id="数据库通知频道">数据库通知频道</h4>
<ol>
<li>
<p>创建表格</p>
<pre><code class="language-php">php artisan notifications:table

php artisan migrate
</code></pre>
</li>
</ol>
<p>我们还需要在users表里新增notification_count字段,用来追踪用户有多少未读通知,如果未读通知大于零的话,就在显示提醒</p>
<pre><code class="language-php">php artisan make:migration add_notification_count_to_users_table --table=users
</code></pre>
<ol start="2">
<li>
<p>生成通知类</p>
<pre><code class="language-php">php artisan make:notification RepliedNotice
</code></pre>
<pre><code class="language-php">&lt;?php
namespace App\Notifications;
use Illuminate\Bus\Queueable;
use Illuminate\Notifications\Notification;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Messages\MailMessage;
use App\Models\Reply;
class RepliedNotice extends Notification
{
 use Queueable;
 public $reply;
 public function __construct(Reply $reply)
 {
 	// 注入回复实体，方便 toDatabase 方法中的使用
 	$this-&gt;reply = $reply;
 }
 public function via($notifiable)
 {
 	// 开启通知的频道
	 return ['database'];
 }
 public function toDatabase($notifiable)
 {
     $topic = $this-&gt;reply-&gt;topic;
     $link = $topic-&gt;link(['#reply' . $this-&gt;reply-&gt;id]);
     // 存入数据库里的数据
     return [
         'reply_id' =&gt; $this-&gt;reply-&gt;id,
         'reply_content' =&gt; $this-&gt;reply-&gt;content,
         'user_id' =&gt; $this-&gt;reply-&gt;user-&gt;id,
         'user_name' =&gt; $this-&gt;reply-&gt;user-&gt;name,
         'user_avatar' =&gt; $this-&gt;reply-&gt;user-&gt;avatar,
         'topic_link' =&gt; $link,
         'topic_id' =&gt; $topic-&gt;id,
         'topic_title' =&gt; $topic-&gt;title,
     ];
 }
}
</code></pre>
<blockquote>
<p>每个通知类都有个 via() 方法，它决定了通知在哪个频道上发送。我们写上 database 数据库来作为通知频道。<br>
因为使用数据库通知频道，我们需要定义 toDatabase() 。这个方法接收 $notifiable 实例参数并返回一个普通的<br>
PHP 数组。这个返回的数组将被转成 JSON 格式并存储到通知数据表的 data 字段中。</p>
</blockquote>
</li>
<li>
<p>通知执行流程</p>
</li>
</ol>
<figure data-type="image" tabindex="2"><img src="assets/1552309644161.png" alt="1552309644161" loading="lazy"></figure>
<ol start="4">
<li>通知阅读流程</li>
</ol>
<figure data-type="image" tabindex="3"><img src="assets/1552477894134.png" alt="1552477894134" loading="lazy"></figure>
<h4 id="邮件通知">邮件通知</h4>
<p>// app\Notifications\RepiedNotice.php 通知类</p>
<pre><code class="language-php">Class RepiedNotice extends Notification
{
    public function __construct(Repied $reply)
    {
        $this-&gt;reply=$reply;
    }
    
    public function via($notifiable)
    {
        return ['databse','mail'];
    }
    
    public function toMail($notifiable)
    {
        $url=$this-&gt;reply-&gt;topic-link(['#reply',$this-&gt;reply-&gt;id]);
        return (new MailMessage)-&gt;subject('邮件标题')-&gt;line('你的话题有新回复')-&gt;action('查看回复',$url);
    }
}
</code></pre>
<h4 id="消息邮件加入队列">消息邮件加入队列</h4>
<p>我们可以通过对通知类添加 ShouldQueue 接口和 Queueable trait 把通知加入队列。它们两个在使用<br>
make:notification 命令来生成通知文件时就已经被导入，我们只需添加到通知类接口即可。</p>
<p>修改 TopicReplied.php 文件，将以下这一行：</p>
<pre><code class="language-php">class TopicReplied extends Notification
</code></pre>
<p>改为：</p>
<pre><code class="language-php">class TopicReplied extends Notification implements ShouldQueue
</code></pre>
<p>Laravel 会检测 ShouldQueue 接口并自动将通知的发送放入队列中，所以我们不需要做其他修改。</p>
<h2 id="第八章-用户权限">第八章 用户权限</h2>
<h3 id="权限扩展包permission">权限扩展包permission</h3>
<p><code>spatie/laravel-permission</code></p>
<h4 id="使用规范">使用规范</h4>
<p>user模型加载HasRoles trait</p>
<pre><code class="language-php">use Spatie\Permission\Traits\HasRoles;
class User extends Authenticatable implements MustVerifyEmailContract
{
 use HasRoles;
}
</code></pre>
<p>权限定义规范我们统一只用_分割法</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>命名</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>内容管理</td>
<td>manage_contents</td>
<td></td>
</tr>
<tr>
<td>用户管理</td>
<td>manage_users</td>
<td></td>
</tr>
<tr>
<td>站点设置</td>
<td>edit_settings</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="站点权限部署">站点权限部署</h4>
<p><strong>策略过滤器</strong></p>
<blockquote>
<p>代码生成器所生成的策略授权,都会统一集成App\Policies\Policy基类,这样我们只需要在基类的before()方法里做下角色权限判断即可坐拥到所有的授权类</p>
</blockquote>
<pre><code class="language-php">public function before($user, $ability)
{
    if($user-&gt;can('manage_contens')){
        return true;
    }
}
</code></pre>
<h4 id="gates-说明">Gates 说明</h4>
<p>授权操作主要有两种方式:gates和策略.</p>
<p>Gates大部分应用在模型和资源没有关系的地方,比如查看管理员的面板.与之相反, 策略应该在特定的模型或者资源中使用.</p>
<p>Horizon 访问权限的设置</p>
<blockquote>
<p>下面代码只有角色为Founder的才能访问horizon面板</p>
</blockquote>
<p>AuthServiceProvider.php</p>
<pre><code class="language-php">    public function boot()
    {
        $this-&gt;registerPolicies();
        //Horizon 访问权限设置
        \Horizon::auth(function ($request) {
            // 是否是站长,这里需要先判断是否登录
            if(!\Auth::check()) return false;
            return \Auth::user()-&gt;hasRole('Founder');
        });
    }
</code></pre>
<h3 id="管理后台包">管理后台包</h3>
<p><code>summerblue/administrator</code></p>
<h4 id="laravel58采坑安装">laravel5.8采坑安装</h4>
<p>https://learnku.com/laravel/t/18675</p>
<blockquote>
<p>错误信息: In AdministratorServiceProvider.php line 48:</p>
<p>Call to undefined method Illuminate\Events\Dispatcher::fire()</p>
<p>解决方法: 搜索AdministratorServiceProvier.php文件按照下面修改fire()方法为dispatch();</p>
<p><a href="https://github.com/latifasaee">@latifasaee</a> In short, when you see an error like this with Laravel 5.8, the call</p>
<pre><code>Call to undefined method Illuminate\Events\Dispatcher::fire() 
</code></pre>
<p>needs to be changed to</p>
<pre><code>Call to undefined method Illuminate\Events\Dispatcher::dispatch() 
</code></pre>
<p>In versions prior to Laravel 5.7, this method classname was <code>fire</code> but with Laravel 5.8, it is now <code>dispatch</code></p>
</blockquote>
<h3 id="用户切换工具sudo-su">用户切换工具sudo-su</h3>
<ol>
<li>
<p>安装插件</p>
<p><code>viacreative/sudo-su</code></p>
</li>
<li>
<p>修改配置文件</p>
<pre><code class="language-php">config/sudosu.php
    //域名后缀限制
'allowed_tlds' =&gt; ['dev', 'local','com'],  
'user_model' =&gt; App\Models\User::class
</code></pre>
</li>
<li>
<p>模板植入</p>
<pre><code class="language-php">//resources/views/layouts/app.blade.php
@if (config('app.debug'))
    @include('sudosu::user-selector')
@endif
</code></pre>
</li>
</ol>
<h3 id="管理后台包-2">管理后台包</h3>
<p>插件: <code>summerblue/administrator</code></p>
<p>创建必要的文件夹</p>
<p>Administrator 会检测<code>model_config_path</code>和 <code>settings_config_path</code>目录是否能正常访问,所以我们需要先新建目录</p>
<pre><code class="language-php">$ mkdir -p config/administrator/settings
$ touch config/administrator/settings/.gitkeep
</code></pre>
<p>在空文件夹中放置 .gitkeep 保证了 Git 会将此文件夹纳入版本控制器中。</p>
<p>bug解决</p>
<p><code>Administrator: 在 administrator.php 的配置中你必须提供一个有效的 'home_page' 参数</code></p>
<p>解决:</p>
<p>https://github.com/summerblue/administrator-demo/blob/master/config/administrator/users.php</p>
<p>将users.php复制到config/administrator/目录下</p>
<p>修改use App\User 为use App\Models\User;</p>
<p>配置文章</p>
<p>https://learnku.com/laravel/t/2407/use-laravel-administrator-to-quickly-generate-data-model-administrator-tutorial</p>
<h2 id="第九章-杂项">第九章 杂项</h2>
<h3 id="边栏活跃用户">边栏活跃用户</h3>
<h4 id="新建artisan-命令">新建artisan 命令</h4>
<pre><code class="language-php">php artisan make:command CalculateActiveUser --command=larabbs:calculate-active-user
</code></pre>
<p>参数<code>--command</code>是指定artisan调用的命令,一般情况下,我们推介为命令加上命名空间,如本项目的<code>larabbs</code></p>
<h4 id="计划任务">计划任务</h4>
<blockquote>
<p>laravel 的计划任务执行思路</p>
<ol>
<li>
<p>在系统的crontab中 先执行schedule:run 命令</p>
</li>
<li>
<p>在app/Console/Kernel.php的schedule方法中定义相关命令</p>
</li>
</ol>
</blockquote>
<p><strong>1.系统cron定义laravel 计划任务命令</strong></p>
<p>修改系统的Cron计划任务配置信息,运行以下命令</p>
<pre><code class="language-php">$ export EDITOR=vi &amp;&amp; crontab -e
</code></pre>
<p>复制下面的这一行</p>
<pre><code class="language-php">* * * * * php /home/vagrant/Code/larabbs/artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1
</code></pre>
<p>2.在<code>app/Console/Kernel.php</code>文件的<code>schedule</code>方法中定义</p>
<pre><code class="language-php">protected function schedule(Schedule $schedule)
 {
 // 一小时执行一次『活跃用户』数据生成的命令
 $schedule-&gt;command('larabbs:calculate-active-user')-&gt;hourly();
 }
</code></pre>
<p>系统的Cron已经设定好了,现在Cron软件将会每分钟调用一次laravel命令调度器,当<code>achedule:run</code>命令执行时,laravel会评估你的计划任务并运行预定任务.</p>
<h3 id="热门文章">热门文章</h3>
<p><code>Cache::remember()</code></p>
<pre><code class="language-php">class Link extends Model
{
    protected $fillable = ['title', 'link'];
    public $cache_key = 'larabbs_links';
    protected $cache_expire_in_minutes = 1440;
    public function getLinkCache()
    {
// 尝试从缓存中取出 cache_key 对应的数据。如果能取到，便直接返回数据。
// 否则运行匿名函数中的代码来取出活跃用户数据，返回的同时做了缓存。
        return \Cache::remember($this-&gt;cache_key, $this-&gt;cache_expire_in_minutes, function(){
            return $this-&gt;all();
        });
    }
}
</code></pre>
<p><code>Cache::forget()</code></p>
<h3 id="避免数据损坏">避免数据损坏</h3>
<blockquote>
<p>我们删除了用户,却没有删除用户发布的话题,此部分话题变成了遗留数据. 话题列表中渲染到这些遗留数据时,因为不存在作者,却取作者的avatar头像属性,故报错.</p>
</blockquote>
<p>处理办法,实现关联数据的删除.</p>
<h4 id="两种处理机制">两种处理机制:</h4>
<ol>
<li>代码监听器 —— 利用 的 deleted 事件连带删除，好处是灵活、扩展性强，不受底层数据库约束，坏处当删除时不添加监听器，就会出现漏删；</li>
<li>外键约束 —— 利用 MySQL 自带的外键约束功能，好处是数据一致性强，基本上不会出现漏删，坏处是有些数据库不支持，如 SQLite。</li>
</ol>
<h4 id="添加外检约束">添加外检约束</h4>
<blockquote>
<p>这里的外键约束，数据库引擎一定要是 InnoDB 类型的。MyISAM 类型不支持外键约束</p>
</blockquote>
<p>1.当用户删除时,删除其发布的话题;</p>
<p>2.当用户删除时,删除其发布的回复;</p>
<p>3.当话题删除时,删除其所属的回复;</p>
<blockquote>
<p>on update和on delete后面可以跟的词语有四个<br>
no action ， set null ， set default ，cascade<br>
no action 表示 不做任何操作，<br>
set null 表示在外键表中将相应字段设置为null<br>
set default 表示设置为默认值<br>
cascade 表示级联操作，就是说，如果主键表中被参考字段更新，外键表中也更新，主键表中的记录被删除，外键表中改行也相应删除</p>
</blockquote>
<pre><code class="language-php">public function up()
    {

        Schema::table('topics',function(Blueprint $table){
            $table-&gt;foreign('user_id')-&gt;references('id')-&gt;on('users')-&gt;onDelete('cascade');
        });

        Schema::table('replies',function(Blueprint $table){
            $table-&gt;foreign('user_id')-&gt;references('id')-&gt;on('users')-&gt;onDelete('cascade');
            $table-&gt;foreign('topic_id')-&gt;references('id')-&gt;on('topics')-&gt;onDelete('cascade');
        });
}
</code></pre>
<h3 id="用户最后登录时间">用户最后登录时间</h3>
<p>数据库题外话:</p>
<blockquote>
<p>然而，在数据库中操作中，『写入』对数据库造成的压力，要远比『读取』压力高得多。想要准确地跟踪用户的最后活跃时间，就必须在用户每一次请求服务器时都做记录，我们使用的主数据是 MySQL，也就是说每当用户访问一个页面，我们都将 MySQL 数据库里的 users 表写入数据。当我们有很多用户频繁访问站点时，这将会是数据库的一笔巨大开销。<br>
我们可以使用 Redis 来记录用户的访问时间，Redis 运行在机器的内存上，读写效率都极快。不过为了保证数据的完整性，我们需要定期将 Redis 数据同步到数据库中，否则一旦 Redis 出问题或者执行了 Redis 清理操作，用户的『最后活跃时间』将会丢失</p>
</blockquote>
<hr>
<h4 id="基本思路">基本思路</h4>
<p><code>基本思路如下</code>：</p>
<ol>
<li>记录 - 通过中间件过滤用户所有请求，记录用户访问时间到 Redis 按日期区分的哈希表；</li>
<li>同步 - 新建命令，计划任务每天运行一次此命令，将昨日哈希表里的数据同步到数据库中，并删除；</li>
<li>读取 - 优先读取当日哈希表里 Redis 里的数据，无数据则使用数据库中的值。</li>
</ol>
<h4 id="前置中间件和后置中间件">前置中间件和后置中间件</h4>
<blockquote>
<p>前置中间件是应用初始化完成以后立刻执行，此时控制器路由还未分配、控制器还未执行、视图还未渲染。后置中间件是即将离开应用的响应，此时控制器已将渲染好的视图返回，我们可以在后置中间件里修改响应。</p>
</blockquote>
<ol>
<li>创建中间件</li>
</ol>
<pre><code class="language-php">php artisan make:middleware RecordLastActived
</code></pre>
<ol start="2">
<li>
<p>注册中间件:在app/Http/Kernel.php类中对中间件进行注册</p>
</li>
<li>
<p>书写中间件</p>
<pre><code class="language-php">class RecordLastActivedTime
{
public function handle($request, Closure $next)
    {
        //如果是登录用户的话
        if(\Auth::check()){
            //    记录最后登录时间
            \Auth::user()-&gt;recordLastActivedAt();
        }
        return $next($request);
    }
}
</code></pre>
</li>
</ol>
<h3 id="总结-缓存操作">总结: 缓存操作</h3>
<h4 id="常用缓存操作">常用缓存操作</h4>
<pre><code class="language-php">//取出缓存,如果不存在则执行function闭包函数中的内容
Cache::remember(key,expired,function(){	
​	return .....
})
//将数据放入缓存中
Cache::put(key,value,expired);
//清除缓存值
Cache::forget(key);
    
</code></pre>
<h4 id="redis-操作">redis 操作</h4>
<pre><code class="language-第php">//$hash 表名, $filed 字段名,$value 字段值
Redis::hset($hash,$field,$value);
</code></pre>
<h2 id="第十章-附注">第十章 附注</h2>
<h3 id="删除按钮policy-优化">删除按钮policy 优化</h3>
<blockquote>
<p>解决文章评论列表删除按钮显示的policy判断,处理方法,在数据分配的时候讲相关模型懒加载.</p>
</blockquote>
<pre><code class="language-php">@include('topics._reply_list',['replies'=&gt;$topic-&gt;reply()-&gt;with('user','topic')-&gt;get()])
</code></pre>
<p>模板中代码</p>
<pre><code class="language-php">@if(count($replies)&gt;0)
    &lt;ul class=&quot;list-group&quot;&gt;
    @foreach($replies as $reply)
    &lt;li class=&quot;list-group-item&quot;&gt;
    &lt;div&gt;{{$reply-&gt;user-&gt;name}}
&lt;i class=&quot;far fa-clock&quot;&gt;&lt;/i&gt; {{$reply-&gt;created_at-&gt;diffForHumans()}}
&lt;/div&gt;
    &lt;div&gt;{{$reply-&gt;content}}&lt;/div&gt;
{{--@can('delete',$reply)--}}
&lt;div class=&quot;text-right&quot;&gt;
    &lt;form action=&quot;{{route('replies.destroy',$reply-&gt;id)}}&quot; method=&quot;post&quot;&gt;
    @csrf
{{method_field('delete')}}
&lt;button type=&quot;submit&quot; class=&quot;btn btn-outline-secondary&quot;&gt;删除&lt;/button&gt;
    &lt;/form&gt;
    &lt;/div&gt;
{{--@endcan--}}
&lt;/li&gt;
    @endforeach
    &lt;/ul&gt;
    @endif

</code></pre>
<h3 id="bootstrap4-flex弹性布局">bootstrap4 flex(弹性)布局</h3>
<pre><code class="language-php">.ml-md-auto 产生效果右对齐,垂直居中
</code></pre>
<h3 id="电子邮箱设置注意">电子邮箱设置注意</h3>
<blockquote>
<p>需要配置, 否则可能出错</p>
<p>MAIL_FROM_ADDRESS=9175020@qq.com<br>
MAIL_FROM_NAME=larabbs</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[转载] Go语言 结构体常见tag]]></title>
        <id>https://bluegrasses.github.io/post/zhuan-zai-go-yu-yan-jie-gou-ti-chang-jian-tag/</id>
        <link href="https://bluegrasses.github.io/post/zhuan-zai-go-yu-yan-jie-gou-ti-chang-jian-tag/">
        </link>
        <updated>2020-11-01T22:07:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是tag">什么是tag</h2>
<p>Tag是结构体中某个字段别名, 可以定义多个, 空格分隔</p>
<pre><code class="language-go">type Student struct {
    Name string `ak:&quot;av&quot; bk:&quot;bv&quot; ck:&quot;cv&quot;`
}
</code></pre>
<p>使用空格来区分多个tag,所以格式要尤为注意</p>
<h2 id="tag的作用">tag的作用</h2>
<p>tag相当于该字段的一个属性标签, 在Go语言中, 一些包通过tag来做相应的判断</p>
<p>举个例子, 比如我们有一个结构体</p>
<pre><code class="language-go">type Student struct {
    Name string
}
</code></pre>
<p>然后我们将一个该结构体实例化一个 s1</p>
<pre><code class="language-go">s1 := Student{
        Name: &quot;s1&quot;,
    }
</code></pre>
<p>再将 s1 序列化</p>
<pre><code class="language-go">v, err := json.Marshal(s1) // json.Marshal方法,json序列化,返回值和报错信息
if err != nil { // 不为nil代表报错
    fmt.Println(err)
}
fmt.Println(string(v)) // []byte转string, json
</code></pre>
<p>此时 string(v) 为</p>
<pre><code class="language-go">{
  &quot;Name&quot;: &quot;s1&quot;  
}
</code></pre>
<p>因为在 Go 语言中, 结构体字段要想为外部所用就必须首字母大写, 但是如果这个 s1 是返回给前端的, 那每个字段都首字母大写就很怪, 此时我们可以给 Student 加tag解决</p>
<p>结构体修改为</p>
<pre><code class="language-go">type Student struct {
    Name string`json:&quot;name&quot;`
}
</code></pre>
<p>序列化时, 会自己找到名为 json 的tag, 根据值来进行json后的赋值</p>
<p>因此 string(v) 为</p>
<pre><code class="language-go">{
  &quot;name&quot;: &quot;s1&quot;  
}
</code></pre>
<h2 id="常用tag记录">常用tag记录</h2>
<h3 id="json">json</h3>
<p>json序列化或反序列化时字段的名称</p>
<h3 id="db">db</h3>
<p>sqlx模块中对应的数据库字段名</p>
<h3 id="form">form</h3>
<p>gin框架中对应的前端的数据字段名</p>
<h3 id="binding">binding</h3>
<p>搭配 form 使用, 默认如果没查找到结构体中的某个字段则不报错值为空, binding为 required 代表没找到返回错误给前端</p>
<p>作者： ChnMig</p>
<p>出处：https://www.cnblogs.com/chnmig/p/1132390.html</p>
<p>版权：本作品采用「<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a>」许可协议进行许可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# {go} cobra ]]></title>
        <id>https://bluegrasses.github.io/post/cobra/</id>
        <link href="https://bluegrasses.github.io/post/cobra/">
        </link>
        <updated>2020-10-10T10:19:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="部署和安装">部署和安装</h2>
<h3 id="安装与导入">安装与导入</h3>
<ul>
<li>安装</li>
</ul>
<pre><code class="language-go">go get -u github.com/spf13/cobra
</code></pre>
<ul>
<li>导入</li>
</ul>
<pre><code class="language-go">import &quot;github.com/spf13/cobra&quot;
</code></pre>
<h4 id="使用cobra生成器">使用cobra生成器</h4>
<p>windows系统下使用：</p>
<pre><code class="language-go">go get github.com/spf13/cobra/cobra
</code></pre>
<p>或者在文件夹<code>github.com/spf13/cobra/cobra</code>下使用<code>go install</code>在<code>$GOPATH/bin</code>路径下生成<code>cobra.exe</code>可执行命令。</p>
<blockquote>
<p>windows 需要把bin目录加入到环境变量中, 重启生效</p>
</blockquote>
<h3 id="使用入门">使用入门</h3>
<h4 id="脚手架方式初始化">脚手架方式初始化</h4>
<pre><code class="language-go">//cli 为gomodule的包名
cobra init  --pkg-name=cli
</code></pre>
<h4 id="添加子命令">添加子命令</h4>
<ul>
<li>脚手架添加子命令</li>
</ul>
<pre><code>cobra add version
</code></pre>
<ul>
<li>代码实现</li>
</ul>
<pre><code class="language-go">//version.go
func init(){
    //rootCmd为根节点
	rootCmd.AddCommand(versionCmd)
}

&gt; go run main.go version
</code></pre>
<h4 id="添加二级子命令">添加二级子命令</h4>
<pre><code class="language-go">//help.go help 为version 的二级命令
var helpCmd=&amp;cobra.Comand{}
func init(){
	versionCmd.AddCommand(helpCmd)
}

&gt; go run main.go version help
</code></pre>
<h4 id="使用flags参数">使用Flags(参数)</h4>
<p><code>Flags提供了修饰符来控制动作命令的操作</code></p>
<ul>
<li>
<p>Persistent Flags：全局性flag, 可用于它所分配的命令以及该命令下的每个命令。在根上分配标志作为全局flag。</p>
</li>
<li>
<p>Local Flags：局部性flag,在本args分配一个标志，该标志仅适用于该特定命令。</p>
</li>
<li>
<p>Required flags：必选flag，flag默认是可选的。如果希望命令在未设置flag时报告错误，请将其标记为required。</p>
</li>
</ul>
<pre><code class="language-go">//version.go
var versionCmd = &amp;cobra.Command{
	Use:   &quot;version&quot;,
	Short: &quot;A brief description of your command&quot;,
	Long: `A longer description`,
	Run: func(cmd *cobra.Command, args []string) {
        //获取参数值
		str, _ := cmd.Flags().GetString(&quot;gfoo&quot;)
		fmt.Printf(&quot;the param vale is %s\n&quot;, str)
		fmt.Println(&quot;version  1.0.0 for cli&quot;)
	},
}
func init() {
	rootCmd.AddCommand(versionCmd)
	//定义Flags 提供了修饰符来控制动作命令的操作,StringP支持简写
	versionCmd.PersistentFlags().String(&quot;gfoo&quot;, &quot;gfoo&quot;, &quot;A help for global_foo&quot;)
	versionCmd.Flags().StringP(&quot;lfoo&quot;, &quot;f&quot;, &quot;&quot;, &quot;a help for local_foo&quot;)
    
}
</code></pre>
<h5 id="获取参数值的其他方法">获取参数值的其他方法</h5>
<pre><code class="language-go">var str string
var wordCmd = &amp;cobra.Command{
	Use:   &quot;version&quot;,
	Short: &quot;A brief description of your command&quot;,
	Long: `A longer description`,
	Run: func(cmd *cobra.Command, args []string) {
		//业务逻辑
	},
}
func init() {
	rootCmd.AddCommand(versionCmd)
	//直接将参数值读取到一个提前申明的变量中
	wordCmd.Flags().StringVarP(&amp;str, &quot;str&quot;, &quot;s&quot;, &quot;&quot;, &quot;请输入单词内容&quot;)
    
}
</code></pre>
<h4 id="args参数约束和检查">Args参数约束和检查</h4>
<pre><code class="language-go">//version.go Run:下面
	Args: func(cmd *cobra.Command, args []string) error {
		if len(args) &lt; 1 {
			return errors.New(&quot;requires at least one arg&quot;)
		}
		return nil
	},
//上面代码可以简写为
	Args: cobra.MinimumNArgs(1),
//version 命令不加参数会报错
&gt; go run main.go version 
</code></pre>
<h4 id="help">help</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[{go} 数据结构和算法-基础篇]]></title>
        <id>https://bluegrasses.github.io/post/go-shu-ju-jie-gou-he-suan-fa-ji-chu-pian/</id>
        <link href="https://bluegrasses.github.io/post/go-shu-ju-jie-gou-he-suan-fa-ji-chu-pian/">
        </link>
        <updated>2020-09-23T12:56:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数据结构">数据结构</h2>
<h3 id="栈-stack">栈 stack</h3>
<pre><code class="language-go">type Stack struct {
	items []int
}
//入栈
func (s *Stack) Push(data int) {
	s.items = append(s.items, data)
}
//出栈
func (s *Stack) Pop() int {
	l := len(s.items) - 1
	popData := s.items[l]
    //切片左包含,右不包含
	s.items = s.items[:l]
	return popData
}

func main() {
	myStack := Stack{}
	myStack.Push(1)
	myStack.Push(2)
	myStack.Push(3)
	myStack.Pop()
	fmt.Println(myStack)
}
</code></pre>
<h3 id="队列queue">队列queue</h3>
<pre><code class="language-go">type Queue struct {
	items []int
}
//入队
func (q *Queue) EnQueen(i int) {
	q.items = append(q.items, i)
}
//出队
func (q *Queue) DeQueen() int {
	UnQueen := q.items[0]
	q.items = q.items[1:]
	return UnQueen
}

func main() {
	myQueen := Queue{}
	myQueen.EnQueen(1)
	myQueen.EnQueen(2)
	myQueen.EnQueen(3)
	myQueen.DeQueen()
	fmt.Println(myQueen)
}
</code></pre>
<h3 id="二叉树">二叉树</h3>
<pre><code class="language-go">var count int

type Node struct {
	Key      int
	LeftSon  *Node
	RightSon *Node
}

//Insert tree中插入值
func (n *Node) Insert(i int) {
	//i&gt;节点值放到右侧,右侧如果没有节点直接放入,有的话递归进行
	if n.Key &lt; i {
		if n.RightSon == nil {
			n.RightSon = &amp;Node{Key: i}
		} else {
			n.RightSon.Insert(i)
		}
	} else if n.Key &gt; i {
		if n.LeftSon == nil {
			n.LeftSon = &amp;Node{Key: i}
		} else {
			n.LeftSon.Insert(i)
		}
	}
}

//Search 如果值正常返回true
func (n *Node) Search(i int) bool {
	count++
	//如果节点到底都没找到,返回false
    if n == nil {
		return false
	}
    //如果大于到右侧寻找,如果小于到左侧寻找,否则返回真(true),递归调用时注意return
	if n.Key &lt; i {
		return n.RightSon.Search(i)
	} else if n.Key &gt; i {
		return n.LeftSon.Search(i)
	}
	return true
}

func main() {
	myNode := &amp;Node{Key: 100}
	myNode.Insert(50)
	myNode.Insert(150)
	myNode.Insert(203)
	myNode.Insert(19)
	myNode.Insert(76)
	myNode.Insert(71)
	myNode.Insert(82)

	fmt.Println(myNode.Search(76))
	fmt.Println(count)
}
</code></pre>
<h3 id="trie-字典">trie (字典)</h3>
<figure data-type="image" tabindex="1"><img src="https://bluegrasses.github.io/post-images/1601039837814.png" alt="" loading="lazy"></figure>
<pre><code class="language-go">const size = 26

//定义一个单元
type Node struct {
	children [size]*Node
	//单词末尾 加isEnd标记
	isEnd bool
}

type Trie struct {
	root *Node
}

//InitTrie 初始化字典,复杂的初始化建议设立一个初始函数
func InitTrie() *Trie {
	result := &amp;Trie{root: &amp;Node{}}
	return result
}

//Insert 插入trie
func (t *Trie) Insert(w string) {
	wordLength := len(w)
	currentNode := t.root
	for i := 0; i &lt; wordLength; i++ {
		charIndex := w[i] - 'a'
		if currentNode.children[charIndex] == nil {
			currentNode.children[charIndex] = &amp;Node{}
		}
		currentNode = currentNode.children[charIndex]
	}
	currentNode.isEnd = true
}

//Search 查询 tries
func (t *Trie) Search(w string) bool {
	wordLength := len(w)
	currentNode := t.root
	for i := 0; i &lt; wordLength; i++ {
		charIndex := w[i] - 'a'
		if currentNode.children[charIndex] == nil {
			return false
		}
		currentNode = currentNode.children[charIndex]
	}
	if currentNode.isEnd == true {
		return true
	}
	return false
}

func main() {
	myTrie := InitTrie()
	myTrie.Insert(&quot;hello&quot;)
	fmt.Println(myTrie.Search(&quot;hello&quot;))
}
</code></pre>
<h3 id="linked-链表">linked 链表</h3>
<figure data-type="image" tabindex="2"><img src="https://bluegrasses.github.io/post-images/1601040093784.png" alt="" loading="lazy"></figure>
<pre><code class="language-go">//定义一个单元
type node struct {
	data int
	next *node
}

type linkedList struct {
	head   *node
	length int
}

//prepend 头部添加一个节点
func (l *linkedList) prepend(n *node) {
	second := l.head
	l.head = n
	l.head.next = second
	l.length++
}

//打印列表
func (l linkedList) printLinked() {
	current := l.head
	for i := 0; i &lt; l.length; i++ {
		fmt.Println(current.data)
		current = current.next
	}
}

//deleteWithValue 删除link制定数值
func (l *linkedList) deleteWithValue(i int) {
	//空link情况
	if l.length == 0 {
		return
	}
	//删除首节点情况
	if l.head.data == i {
		l.head = l.head.next
		l.length--
		return
	}
	current := l.head
	for current.next.data != i {
		current = current.next
		//没有匹配值的情况
		if current.next == nil {
			return
		}
	}
	current.next = current.next.next
	l.length--
}

func main() {
	node1 := &amp;node{data: 48}
	node2 := &amp;node{data: 16}
	node3 := &amp;node{data: 32}
	myLink := linkedList{}
	myLink.prepend(node1)
	myLink.prepend(node2)
	myLink.prepend(node3)
	myLink.printLinked()
	myLink.deleteWithValue(16)
	myLink.printLinked()
}

</code></pre>
<h3 id="hash">hash</h3>
<p>图解:<br>
<img src="https://bluegrasses.github.io/post-images/1601107673005.png" alt="" loading="lazy"><br>
代码:</p>
<pre><code class="language-go">//ArraySize hash数组长度
const ArraySize int = 7

//HashTable 哈希表struct结构体
type HashTable struct {
	//hash表长度
	array [ArraySize]*bucket
}

//bucket struct
type bucket struct {
	head *bucketNode
}

type bucketNode struct {
	key  string
	next *bucketNode
}

func (h *HashTable) Insert(key string) {
	index := hash(key)
	h.array[index].Insert(key)
}

func (h *HashTable) Search(key string) bool {
	index := hash(key)
	return h.array[index].Search(key)
}

func (h *HashTable) Delete(key string) {
	index := hash(key)
	h.array[index].Delete(key)
}

func (b *bucket) Insert(k string) {
	if !b.Search(k) {
		second := b.head
		b.head = &amp;bucketNode{key: k}
		b.head.next = second
	} else {
		fmt.Println(&quot;k&quot;, &quot;is exists&quot;)
	}

}

func (b *bucket) Search(key string) bool {
	current := b.head
	for current != nil {
		if current.key == key {
			return true
		}
		current = current.next
	}
	return false
}

func (b *bucket) Delete(key string) {
	if b.head.key == key {
		b.head = b.head.next
		return
	}
	current := b.head
	for current.next != nil {
		if current.next.key == key {
			current.next = current.next.next
			return
		}
		current = current.next
	}
}

//Init 初始化函数,注意init为go的系统关键字,先于系统main函数执行
func Init() *HashTable {
	obj := &amp;HashTable{}
	for i := range obj.array {
		obj.array[i] = &amp;bucket{}
	}
	return obj
}

func hash(key string) int {
	sum := 0
	for _, v := range key {
		sum += int(v)
	}
	return sum % ArraySize
}

func main() {
	ht := Init()
	list := []string{
		&quot;eric&quot;,
		&quot;kyle&quot;,
		&quot;stan&quot;,
		&quot;token&quot;,
	}
	for _, v := range list {
		ht.Insert(v)
	}
	ht.Search(&quot;token&quot;)
	ht.Delete(&quot;token&quot;)
	ht.Search(&quot;token&quot;)
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[{go} 测试用例]]></title>
        <id>https://bluegrasses.github.io/post/go-ce-shi-yong-li/</id>
        <link href="https://bluegrasses.github.io/post/go-ce-shi-yong-li/">
        </link>
        <updated>2020-06-21T10:33:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-单元测试">一. 单元测试</h2>
<h3 id="格式要求">格式要求</h3>
<ol>
<li>文件名必须是*_test.go的类型，*代表要测试的文件名</li>
<li>函数名必须以Test开头如：TestXxx或Test_xxx</li>
<li>测试函数TestXxx(<em>testing.T)的参数是</em>testing.T</li>
</ol>
<h3 id="测试方法">测试方法</h3>
<ol>
<li>测试单个文件<br>
go test -v  func_test.go func.go<br>
//或者<br>
go test -v -run func.go</li>
<li>测试单个方法<br>
go test -v -test.run TestAdd<br>
//或者<br>
go test -v -run TestAdd</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[{go} 使用vscode进行断点调试]]></title>
        <id>https://bluegrasses.github.io/post/go-shi-yong-vscode-jin-xing-duan-dian-diao-shi/</id>
        <link href="https://bluegrasses.github.io/post/go-shi-yong-vscode-jin-xing-duan-dian-diao-shi/">
        </link>
        <updated>2020-06-07T03:42:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-环境部署">一 . 环境部署</h2>
<h3 id="安装delv">安装delv</h3>
<p><code>go get -u github.com/go-delve/delve/cmd/dlv</code></p>
<h3 id="安装-debugger-for-chrome">安装 debugger for chrome</h3>
<blockquote>
<p>可选 为了调试http请求</p>
</blockquote>
<h3 id="设置参数">设置参数</h3>
<p><code>vscode-&gt;运行-&gt;打开配置</code><br>
launch.json</p>
<pre><code class="language-json">{
    // 使用 IntelliSense 了解相关属性。 
    // 悬停以查看现有属性的描述。
    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
 
        {
            &quot;name&quot;: &quot;Launch&quot;,
            &quot;type&quot;: &quot;go&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;mode&quot;: &quot;debug&quot;,
            &quot;host&quot;: &quot;127.0.0.1&quot;,
            &quot;port&quot;: 2345,
            &quot;program&quot;: &quot;${fileDirname}&quot;,
            &quot;env&quot;: {},
            &quot;args&quot;: [],
            &quot;showLog&quot;: true
        }
    ]
}
</code></pre>
<h2 id="二-使用">二 . 使用</h2>
<figure data-type="image" tabindex="1"><img src="https://bluegrasses.github.io/post-images/1591501640237.png" alt="" loading="lazy"></figure>
<h3 id="常用调试快捷键">常用调试快捷键</h3>
<p>继续 / 暂停 F5<br>
跳过 F10<br>
进入 F11<br>
退出 Shift+F11<br>
重新开始 unassigned<br>
停止调试 Shift+F5</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[{go} 标准库之 http]]></title>
        <id>https://bluegrasses.github.io/post/go-biao-zhun-ku-http/</id>
        <link href="https://bluegrasses.github.io/post/go-biao-zhun-ku-http/">
        </link>
        <updated>2020-05-27T02:09:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-http">一.  http</h2>
<h3 id="do">do</h3>
<pre><code class="language-go">client := &amp;http.Client{}
request, err := http.NewRequest(&quot;GET&quot;, &quot;http://www.hoopchina.com&quot;, nil)
resp, err := client.Do(request)
body, err := ioutil.ReadAll(resp.Body)
if err := resp.Body.Close(); err != nil {
    log.Fatalln(err)
}
fmt.Println(string(body))
</code></pre>
<h3 id="get">get</h3>
<pre><code class="language-go">client := http.Client{}
resp, err := client.Get(&quot;http://www.baidu.com&quot;)
body, err := ioutil.ReadAll(resp.Body)
if err := resp.Body.Close(); err != nil {
    log.Fatalln(err)
}
fmt.Println(string(body))
</code></pre>
<h3 id="post">post</h3>
<pre><code class="language-go">client := &amp;http.Client{}
resp, err := client.Post(&quot;http://www.baidu.com&quot;, &quot;text/html&quot;, nil)
body, err := ioutil.ReadAll(resp.Body)
if err := resp.Body.Close(); err != nil {
    log.Fatalln(err)
}
fmt.Println(string(body))
</code></pre>
<h3 id="postform">postForm</h3>
<pre><code class="language-go">client := &amp;http.Client{}
data := url.Values{}
data.Add(&quot;name&quot;, &quot;beijing&quot;)
resp, err := client.PostForm(&quot;http://www.baidu.com&quot;, data)
body, err := ioutil.ReadAll(resp.Body)
if err := resp.Body.Close(); err != nil {
    log.Fatalln(err)
}
fmt.Println(string(body))
</code></pre>
<h3 id="server">server</h3>
<pre><code class="language-go">// ` 代表不转义
const html = `&lt;form method=&quot;POST&quot;&gt;
&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;
&lt;input type=&quot;submit&quot; value=&quot;send&quot;&gt;
&lt;/form&gt;`
//启动http 活动
func server() {
	http.HandleFunc(&quot;/&quot;, GetFormHandler)
	log.Fatal(http.ListenAndServe(&quot;:9000&quot;, nil))
}

//GetFormHandler 函数
func GetFormHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set(&quot;Content-Type&quot;, &quot;text/html&quot;)
	if r.Method == &quot;POST&quot; {
		name := r.FormValue(&quot;name&quot;)
		if name != &quot;&quot; {
			fmt.Fprintln(w, &quot;REcevied&quot;, name)
			return
		}
	}
	fmt.Fprintln(w, html)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[{go} 标准库之 FilePath ]]></title>
        <id>https://bluegrasses.github.io/post/go-filepath/</id>
        <link href="https://bluegrasses.github.io/post/go-filepath/">
        </link>
        <updated>2020-05-25T07:49:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本操作">基本操作</h2>
<h3 id="abs-绝对路径">Abs 绝对路径</h3>
<pre><code class="language-go">absPath := &quot;Z:\\个人区\\golang\\study\\libs\\go.mod&quot;
absPath, err := filepath.Abs(&quot;./go.mod&quot;)
</code></pre>
<h3 id="rel-相对路径">Rel 相对路径</h3>
<pre><code class="language-go">absPath := &quot;Z:\\个人区\\golang\\study\\libs\\go.mod&quot;
relPath, err := filepath.Rel(&quot;Z:\\个人区\\&quot;, absPath)
</code></pre>
<h3 id="dir目录-base文件名-ext后缀">Dir(目录) Base(文件名) Ext(后缀)</h3>
<pre><code class="language-go">dir := filepath.Dir(absPath)
base := filepath.Base(absPath)
ext := filepath.Ext(absPath)
</code></pre>
<h3 id="split-路径分隔">Split 路径分隔</h3>
<p>//如果路径中没有路径分隔符，函数返回值 dir 为空字符串，file 等于 path；<br>
//反之，如果路径中最后一个字符是 /，则 dir 等于 path，file 为空字符串。</p>
<pre><code class="language-go">filepath.Split(&quot;Z:\\个人区\\golang\\study\\libs\\go.mod&quot;)
</code></pre>
<h3 id="clean-路径整理">Clean 路径整理</h3>
<pre><code class="language-go">	uncleanPath := &quot;/Users/Benjamin/./../../Users/Benjamin/Workspace&quot;
	cleaned := filepath.Clean(uncleanPath)
</code></pre>
<h3 id="glob-路径匹配">Glob 路径匹配</h3>
<pre><code class="language-go">pattern := &quot;osdemo/*.go&quot;
filepaths, err := filepath.Glob(pattern)
</code></pre>
<h3 id="hasprefix-文件名是否有前缀">hasPrefix 文件名是否有前缀</h3>
<pre><code class="language-go">result := filepath.HasPrefix(&quot;main.go&quot;, &quot;main&quot;)
</code></pre>
<h3 id="match-路径匹配">match 路径匹配</h3>
<pre><code class="language-go">pattern := &quot;main.*&quot;
name := &quot;main.go&quot;
matched, err := filepath.Match(pattern, name)
</code></pre>
<ul>
<li>toSlash 路径替换为反斜杠</li>
</ul>
<h3 id="walk-遍历目录">walk 遍历目录</h3>
<pre><code class="language-go">	currentDir, err := os.Getwd()
	filepath.Walk(currentDir, walkfn)

func walkfn(path string, fileInfo os.FileInfo, _ error) error {
	fmt.Println(&quot;string:&quot;, path, &quot;info:&quot;, fileInfo.Name())
	return nil
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[{go} 标准库之 os详解]]></title>
        <id>https://bluegrasses.github.io/post/gobiao-zhun-ku-os-xiang-jie/</id>
        <link href="https://bluegrasses.github.io/post/gobiao-zhun-ku-os-xiang-jie/">
        </link>
        <updated>2020-05-24T00:27:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="文件文件夹相关操作">文件(文件夹)相关操作</h2>
<h3 id="文件文件夹常用操作">文件(文件夹)常用操作</h3>
<p>Create 新建文件<br>
Remove 删除<br>
RemoveAll 删除<br>
Mkdir 创建文件夹<br>
Mkdir 创建文件夹可以递归<br>
Rename 改名字<br>
Open 打开<br>
OpenFile 打开文件<br>
<code>OpenFile的使用</code></p>
<pre><code class="language-go">//创建并打开
os.OpenFile(&quot;file.txt&quot;, os.O_CREATE|os.O_RDWR, 0755)
//追加并打开
os.OpenFile(&quot;file.txt&quot;, os.O_APPEND|os.O_RDWR, 0777)
</code></pre>
<p>Stat 返回FileInfo对象</p>
<pre><code>os.Stat(&quot;file&quot;)
</code></pre>
<h3 id="file-文件操作">file 文件操作</h3>
<p>Read 读取文件内容<br>
ReadAt 读取指定偏移的文件内容<br>
ReadDir 好像只能读取一层</p>
<pre><code class="language-go">//返回一个文件类型切片
fi, err := f.Readdir(0)
</code></pre>
<p>Seek 跳转文件指针</p>
<pre><code class="language-go">//第一个参数为偏移量,可以为正负数, 第二个参数为偏移基准. 0位从开始,1表示从当前位置,2表示从末尾
file.Seek(7,1)
</code></pre>
<p>Trucate 文件截取<br>
Sync 内容从内存中提交到硬盘<br>
Write 文件写入<br>
WriteString 文件以字符串形式写入<br>
Stat 返回FileInfo对象</p>
<pre><code class="language-go">file.Stat()
</code></pre>
<h3 id="fileinfo">fileInfo</h3>
<p>Name 文件名<br>
Size 文件大小</p>
<ul>
<li>FileMode struct<br>
<code>fileInfo.Mode().IsDir()</code></li>
</ul>
<h2 id="环境相关">环境相关</h2>
<h3 id="env-检测">env 检测</h3>
<ul>
<li>Environ</li>
</ul>
<pre><code class="language-go">	vars := os.Environ()
	for _, env := range vars {
		fmt.Println(env)
	}
</code></pre>
<pre><code class="language-go">path, err := os.LookupEnv(&quot;PATH&quot;)
</code></pre>
<ul>
<li>Expand</li>
</ul>
<pre><code class="language-go">path1 := os.Expand(&quot;$PATH&quot;, os.Getenv)
</code></pre>
<ul>
<li>Hostname<pre><code class="language-go"></code></pre>
</li>
</ul>
<p>os.Hostname()</p>
<pre><code>设置env
```go
err := os.Setenv(&quot;TMPENV&quot;, &quot;values for testenv&quot;)
</code></pre>
<h3 id="判断">判断</h3>
<ul>
<li>判断错误的IsExist 和isNotExist</li>
</ul>
<pre><code class="language-go">err := os.Mkdir(&quot;tmp&quot;, os.ModePerm)
if os.IsExist(err) {
    ....
}
</code></pre>
<ul>
<li>IsPermission 是否有权限</li>
</ul>
<pre><code class="language-go">file, err := os.OpenFile(&quot;file.txt&quot;, os.O_WRONLY, 0644)
os.IsPermission(err)
</code></pre>
]]></content>
    </entry>
</feed>